## Springboot 개념정리
8, 9, 10강
[(강의 링크)](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/dashboard)    

### 스프링부트 동작원리
<br>

## 1. 내장 톰캣을 가진다.
`socket` : 운영체제가 가지고 있는 것으로, 통신을 위해 사용한다.
#### 소켓통신 : 실시간(양방향) 방식
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/aab210ef-e24c-4156-808c-e875e96a3099)
A : 서버, B, C : 클라이언트
```
ex)
  ▪ A와 B가 통신을 하고 싶을 때
    1. A가 5000번에 해당하는 소켓의 포트를 연다.
    2. B가 A의 ip주소와 포트번호를 new socket에 넣으면 5000번 포트를 통해서 A와 B가 연결이 되고, message를 주고받는다.
  
  ▪ 만일 C도 A와 통신을 하고 싶다면?
    : 현재 A와 B는 main 스레드가 관리하는 5000번 포트로 연결되어 통신중 이므로 A는 다른 객체와 연결을 시작할 수 없다.
    : 따라서 소캣 통신에서는 멀티스레드 환경이 필요하다.
    1. main 스레드가 관리하는 5000번 포트는 단순히 A와 다른 객체의 연결만을 관리한다.
    2. A와 연결하고 싶은 B, C는 5000번 포트를 통해 연결을 받는다.
    3. 연결을 받은 B, C는 main 스레드가 아닌, 스레드 1, 2가 관리하는 포트 5001, 5002를 통해 message를 주고받는다.
    4. 이때 B, C는 A와 연결되어 (포트 5001, 5002에 연결되면) A의 5000번 포트와는 연결을 끊어서 추후 다른 객체가 연결을 받을 수 있게한다.

   - 멀티 스레드를 통해 A가 B, C와 동시동작처럼 보이지만, time slice(시간을 쪼개서)로 동작한다.
```
- `소켓 통신`은 한번 연결된 대상과는 끊임없이 통신할 수 있지만, 연결된 소캣이 늘어날수록 부하가 늘어난다.
---
#### HTTP 통신 : stateless 방식
```
  ▪ B, C가 A와 통신하고 싶을 때
    1. 먼저 요청한 순서대로 B가 A의 소켓에 요청을 넣으면, 요청한 message를 넘겨주고 해당 대상과의 연결을 끊는다.(stateless방식)
    2. 그 다음 C와도 동일한 방식으로 연결한다.

  ▪ stateless방식 때문에 A는 이전에 연결했던 대상의 상황을 알 수 없다.

  ▪ 갑(웹서버) 와 을(클라이언트)이 HTTP 방식으로 통신할 경우
    1. 을 `Request` to 갑 (Request : 갑의 IP 주소 + URL( 원하는데이터의 주소))
    2. 갑 `Response` to 을 with Static 자원 (을이 요청한 데이터로 html, js, css, image 등의 누구에게나 항상 같은 데이터인 물리적인 파일)
    ▫ 이 과정이 끝이다. 이를 통해 갑은 을의 IP주소를 알지 못하며, 알고싶다면 HTTP 통신이 아닌 socket통신을 이용해야 한다는 것을 알수 있다.
```
  - `HTTP 통신`은 특정 데이터(static 자원)를 Request를 해야 Response를 하는 구조이다. 
---
#### 웹서버
: 클라이언트로부터 HTTP 요청을 받아서 static 자원을 반환
웹서버에서는 `APACH`(아파치)가 사용된다.

##### APACH (static)
  - 정적인 데이터를 처리하는 웹서버
  - Request가 들어오면, static 자원에 대해 response해준다.
  - 그럼 static 자원 이외의 것을 요청하면? 응답못해준다.

##### TOMCAT (dynamic)
  - 동적인 데이터를 처리하는 웹서버 (WAS)
  - .jsp를 컴파일해서 요청한 데이터를 파악한 후 이를 HTML문서로 만든다.
  - 즉, TOMCAT은.jsp(자바 코드)로 구현할 수 있는 모든 동적인 데이터(DB, APP등)를 정적인 데이터 HTML로 변경해준다.

##### 따라서, 웹서버는 APACH와 TOMCAT을 사용해서 클라이언트의 요청에 응답한다.
- if 동적 데이터를 요청한 경우,
1. 자바코드로 구성된 데이터 요청
2. APACH에서 TOMCAT으로 제어권 변경
3. TOMCAT이 자바 컴파일
4. 컴파일한 데이터를 html(정적 데이터)로 만듬
5. 정적 데이터를 APACH에게 제공
6. APACH는 정적 데이터를 응답
<br>

## 2. 서블릿 컨테이너
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/c2b5943c-564f-49e8-a1e6-989dd69bdb92)   
기존에는 이런식으로 요청이 들어오면 모든 요청에 대해 프로세스를 하나씩 만들었다.(CGI, Common Gateway Interface)
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/17c40f3f-410a-4d76-a4a5-9944bbd4f981)   
하지만 서블릿을 통해 몇개의 요청이 들어오던 프로세스1개에 요청마다 스레드를 지정하여 response할 수 있게 되었다.

<결론>
각 요청마다 새로운 프로세스를 생성해서 높은 오버헤드가 유발된 CGI를 개선해서 1개의 프로세스에 여러개의 스레드를 생성&재사용하는 서블릿을 사용하게 된다.

#### 서블릿과 서블릿 컨테이너
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/dd46364b-cffb-43e1-b1d2-dd440ae1cc4a)   
  - 서블릿 컨테이너 : 서블릿을 관리하고 실행하는 sw로 서블릿의 생명주기를 관리 (init(), service(), destroy() 실행)
  - 서블릿 : java로 작성된 클래스와 객체부분으로 DB상호작용, 로직 수행등의 역할(실질적인 데이터 요청을 수행하는 곳)

##### request response 과정 with 서블릿
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/fcb39356-8a84-4bef-be75-f13d213cabe6)

  1. 클라이언트가 요청하면, 서블릿 컨테이너(톰캣)이 요청을 받아서 최초 요청일 경우 서블릿 객체를 생성하고(new), init()으로 초기화한다. 최초 요청이 아니라면 이미 있던 서블릿 객체를 재사용한다.

  2. 서블릿 컨테이너(톰캣)은 스레드를 만들고, service()를 호출하여 클라이언트의 요청을 처리한다.
      - doGet() : HTTP GET 요청처리, 데이터 읽고 가져올 때 사용 ex) 데이터 검색, 이미지 요청
      - doPost() : HTTP POST 요청처리, 데이터 생성할 때 사용 ex) 설문 폼 데이터 제출
      - doPut() : HTTP PUT 요청처리, 데이터를 업데이트할 때 사용 ex) 비밀번호 변경
      - doDelete() : HTTP DELETE 요청처리, 데이터를 삭제할 때 사용 ex) 장바구니 비우기 

  3. service()의 처리 내용에 따라 위 4가지 메서드를 서블릿 객체에서 처리한다.

  4. 처리된 데이터내용을 서블릿 컨테이너가 클라이언트에게 응답한다.

  5. 클라이언트의 요청에 대응해서 스레드는 계속만들어지고, 서블릿 객체는 최초 요청때 생성 후 계속 1개로 사용된다. (스레드는 여러개 가능, 서블릿 객체는 1개)

  6. 만약 서블릿 컨테이너(톰캣)이 설정한 스레드 개수보다 더 많은 요청이 들어온다면, 스레드를 재사용(pooling)할 수 있을 때까지 대기한다.

  7. 스레드와 서블릿객체는 각각 app이 끝나고 서블릿컨테이너가 destroy() 하기 전까지 재사용된다.

```
+추가
1. 클라이언트가 정적인 파일(html, css, .png)을 요청하게되면 아팟치가, 동적인 파일(자바 파일)을 요청하면 서블릿 컨테이너(톰캣)이 실행된다.
    • BUT! 스프링에서는 정적인 파일을 요청할 수 없다.
    • WHY? 스프링에서는 URL 접근을 막아뒀다. 그래서 URI를 통해 접근하게 되는데 이는 특정한 파일 요청은 할 수 없기 때문에 무조건 자바를 거친다.
    • So, 톰캣이 제어권을 갖는다.
      ▫ URL(Location) : 자원을 통해서 접근할 때 사용하는 주소, URI(Identify) : 식별자을 통해서 접근할 때 사용하는 주소
        - URL : http://naver.com/a.png, URI : http://naver.com/picture/a
        - 여기서 URL의 a.png == 자원, URI의 picture/a == 식별자

2. 서블릿 객체는 한번만 만들고 스레드는 클라이언트 요청마다 만드는 이유?
    • java에서 new를 이용해서 객체를 생성하면, static이 아닌 메서드는 heap에 한번만 저장되지만, 메서드를 실행할 경우 stack에 실행횟수만큼 저장된다.(메서드 실행으로 인해 메서드 내에서 필요한 메모리공간을 스택에서 사용하기 때문)
    • 즉, 메서드는 독립적이므로 서블릿 객체는 재사용할지라도 service()메서드부터는 요청마다 다른 스레드가 필요하다.
```

##### 그럼, 스레드를 많이 만들수록 응답속도가 빠르겠네? 스레드는 어떻게 해야 많이 만들 수 있어?
-> 컴퓨터 성능이 좋으면 됩니다. : scale-up (스레드를 1000개 만들 수 있는 컴퓨터 1개)
-> 컴퓨터를 많이 두면 됩니다. : scale - out (스레드를 100개 만들 수 있는 컴퓨터 10개)




















