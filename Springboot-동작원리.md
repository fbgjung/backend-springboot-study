## Springboot 개념정리
8, 9, 10강
[(강의 링크)](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/dashboard)    

### 스프링부트 동작원리
<br>

## 1. 내장 톰캣을 가진다.
`socket` : 운영체제가 가지고 있는 것으로, 통신을 위해 사용한다.
#### 소켓통신 : 실시간(양방향) 방식
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/aab210ef-e24c-4156-808c-e875e96a3099)
A : 서버, B, C : 클라이언트
```
ex)
  ▪ A와 B가 통신을 하고 싶을 때
    1. A가 5000번에 해당하는 소켓의 포트를 연다.
    2. B가 A의 ip주소와 포트번호를 new socket에 넣으면 5000번 포트를 통해서 A와 B가 연결이 되고, message를 주고받는다.
  
  ▪ 만일 C도 A와 통신을 하고 싶다면?
    : 현재 A와 B는 main 스레드가 관리하는 5000번 포트로 연결되어 통신중 이므로 A는 다른 객체와 연결을 시작할 수 없다.
    : 따라서 소캣 통신에서는 멀티스레드 환경이 필요하다.
    1. main 스레드가 관리하는 5000번 포트는 단순히 A와 다른 객체의 연결만을 관리한다.
    2. A와 연결하고 싶은 B, C는 5000번 포트를 통해 연결을 받는다.
    3. 연결을 받은 B, C는 main 스레드가 아닌, 스레드 1, 2가 관리하는 포트 5001, 5002를 통해 message를 주고받는다.
    4. 이때 B, C는 A와 연결되어 (포트 5001, 5002에 연결되면) A의 5000번 포트와는 연결을 끊어서 추후 다른 객체가 연결을 받을 수 있게한다.

   - 멀티 스레드를 통해 A가 B, C와 동시동작처럼 보이지만, time slice(시간을 쪼개서)로 동작한다.
```
- `소켓 통신`은 한번 연결된 대상과는 끊임없이 통신할 수 있지만, 연결된 소캣이 늘어날수록 부하가 늘어난다.
---
#### HTTP 통신 : stateless 방식
```
  ▪ B, C가 A와 통신하고 싶을 때
    1. 먼저 요청한 순서대로 B가 A의 소켓에 요청을 넣으면, 요청한 message를 넘겨주고 해당 대상과의 연결을 끊는다.(stateless방식)
    2. 그 다음 C와도 동일한 방식으로 연결한다.

  ▪ stateless방식 때문에 A는 이전에 연결했던 대상의 상황을 알 수 없다.

  ▪ 갑(웹서버) 와 을(클라이언트)이 HTTP 방식으로 통신할 경우
    1. 을 `Request` to 갑 (Request : 갑의 IP 주소 + URL( 원하는데이터의 주소))
    2. 갑 `Response` to 을 with Static 자원 (을이 요청한 데이터로 html, js, css, image 등의 누구에게나 항상 같은 데이터인 물리적인 파일)
    ▫ 이 과정이 끝이다. 이를 통해 갑은 을의 IP주소를 알지 못하며, 알고싶다면 HTTP 통신이 아닌 socket통신을 이용해야 한다는 것을 알수 있다.
```
  - `HTTP 통신`은 특정 데이터(static 자원)를 Request를 해야 Response를 하는 구조이다. 
---
#### 웹서버
: 클라이언트로부터 HTTP 요청을 받아서 static 자원을 반환
웹서버에서는 `APACH`(아파치)가 사용된다.

##### APACH (static)
  - 정적인 데이터를 처리하는 웹서버
  - Request가 들어오면, static 자원에 대해 response해준다.
  - 그럼 static 자원 이외의 것을 요청하면? 응답못해준다.

##### TOMCAT (dynamic)
  - 동적인 데이터를 처리하는 웹서버 (WAS)
  - .jsp를 컴파일해서 요청한 데이터를 파악한 후 이를 HTML문서로 만든다.
  - 즉, TOMCAT은.jsp(자바 코드)로 구현할 수 있는 모든 동적인 데이터(DB, APP등)를 정적인 데이터 HTML로 변경해준다.

##### 따라서, 웹서버는 APACH와 TOMCAT을 사용해서 클라이언트의 요청에 응답한다.
- if 동적 데이터를 요청한 경우,
1. 자바코드로 구성된 데이터 요청
2. APACH에서 TOMCAT으로 제어권 변경
3. TOMCAT이 자바 컴파일
4. 컴파일한 데이터를 html(정적 데이터)로 만듬
5. 정적 데이터를 APACH에게 제공
6. APACH는 정적 데이터를 응답
<br>

## 2. 서블릿 컨테이너
  - 클라이언트가 요청하면, 서블릿 컨테이너(톰캣)이 요청을 받아서 최초 요청일 경우 객체를 생성하고, 아니라면 이미 있던 객체를 재사용한다.
  - 정적인 파일(html, css, .png)을 요청하게되면 아팟치가 실행된다.
  - BUT 자바파일을 요청하면 톰캣이 실행, 스프링에서는 정적인 파일을 요청X
        - URL(Location) : 자원을 통해서 접근할 때 사용하는 주소, URI(Identify) : 식별자을 통해서 접근할 때 사용하는 주소 -> 특정한 파일 요청은 할 수 없다, 요청시 무조건 자바를 거친다. -> 톰캣이 제어권을 갖는다.
        - 스프링에서는 URL 접근을 막아둠
        - URL : http://naver.com/a.png URI : http://naver.com/picture/a
        - 여기서 URL의 a.png == 자원, URI의 picture/a == 식별자

  - java관련 자원이 request를 하면, 서블릿 컨테이너(톰캣)에서
      1. (최초 요청시)서블릿 객체 생성(new)
      2. 초기화 메서드 init()호출
      3. 스레드1 만들고 요청종류 확인 메서드 service()호출 (Post, Get, Put, Delete확인)
      4. service의 판단에 따라 Post(), Get(), Put(), Delete() 메서드가 실행
      5. get()의 경우 DB연결, 데이터 수집, 데이터를 html에 담아서 응답
      6. 만약 재 요청시, 1.번 생략, 2번 생략, 3번의 스레드2를 만들어서 service() 호출
          -> 이유 : java에서 new를 이용해서 객체를 생성하면, static이 아닌 메서드는 heap에 한번만 저장되지만, 메서드를 실행할 경우 stack에 실행횟수만큼 저장된다.(메서드 실행으로 인해 메서드 내에서 필요한 메모리공간을 스택에서 사용하기 때문)
          -> 즉, 메서드는 독립적이므로 서블릿객체는 재사용할지라도 service()메서드부터는 요청마다 다른 스레드가 필요하다.
      8. 여기서 톰캣의 기본설정인 스레드 Auto라는 스레드 개수에 대한 설정이 들어간다. 만약 20개로 정한다면, 21번째 요청한 사람은 1번 스레드가 요청에 대한 응답후(response) 종료될때까지 대기해야한다.
          그럼 21번째 요청은 1번스레드를 재사용(pooling)한다.




















