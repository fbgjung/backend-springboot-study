## Springboot 개념정리
8강 
[(강의 링크)](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/dashboard)    

### 스프링부트 동작원리
<br>

#### 1. 내장 톰캣을 가진다.
`socket` : 운영체제가 가지고 있는 것으로, 통신을 위해 사용한다.
##### 소켓통신 : 실시간(양방향) 방식
![image](https://github.com/ssIIIn0-0/backend-springboot-study/assets/62862307/aab210ef-e24c-4156-808c-e875e96a3099)
  - A와 B가 통신을 하고 싶을 때
    1. A가 5000번에 해당하는 소켓의 포트를 연다.
    2. 누가?? A의 ip주소와 포트번호를 어디에?? 넣으면 5000번 포트를 통해서 A와 B가 연결이 되고, message를 주고받는다.
  - 만일 C도 A와 통신을 하고 싶다면?
    : 현재 A와 B는 main 스레드가 관리하는 5000번 포트로 연결되어 통신중 이므로 A는 다른 객체와 연결을 시작할 수 없다.
    : 따라서 소캣 통신에서는 멀티스레드 환경이 필요하다.
    1. main 스레드가 관리하는 5000번 포트는 단순히 A와 다른 객체의 연결만을 관리한다.
    2. A와 연결하고 싶은 B, C는 5000번 포트를 통해 연결을 받는다.
    3. 연결을 받은 B, C는 main 스레드가 아닌, 스레드 1, 2가 관리하는 포트 5001, 5002를 통해 message를 주고받는다.
    4. 이때 B, C는 A와 연결되어 (포트 5001, 5002에 연결되면) A의 5000번 포트와는 연결을 끊어서 추후 다른 객체가 연결을 받을 수 있게한다.
   - 멀티 스레드를 통해 A가 B, C와 동시동작처럼 보이지만, time slice(시간을 쪼개서)로 동작한다.

소켓통신은 한번 연결된 대상과는 끊임없이 통신할 수 있지만, 연결된 소캣이 늘어날수록 부하가 늘어난다.

##### HTTP 통신 : stateless 방식
  - B, C가 A와 통신하고 싶을 때
    1. 먼저 요청한 순서대로 B가 A의 소켓에 요청을 넣으면, 요청한 message를 넘겨주고 해당 대상과의 연결을 끊는다.(stateless방식)
    2. 그 다음 C와도 동일한 방식으로 연결한다.
    - stateless방식 때문에 A는 이전에 연결했던 대상의 상황을 알 수 없다.
