# 8,9,10강 - 스프링부트 동작원리

[8] HTTP가 무엇일까요? 정확히 알아야 해요

[9] 톰켓이란 무엇인가요?

[10] 서블릿 객체의 생명주기가 궁금해요!

[11] 웹 베포서술사(web.xml)에 대해서 알려줘요!

[스프링부트 with JPA 3강 - Springboot 동작원리!](https://getinthere.tistory.com/11)

---

# 8강 - HTTP가 무엇인가

## ✅ HTTP란?

통신규약, 웹서비스에서 클라이언트와 서버 간의 정보를 요청하고 응답받기 위한 프로토콜

### 특징

**1.  단방향 통신** (클라이언트 요청-서버 응답)

**2.  무상태 Stateless 프로토콜 지향** 

- 서버가 클라이언트의 연결/상태 정보를 보존하지 않는다.
- 장점 → 클라이언트 요청에 어떤 서버가 응답 해도 상관 없기 때문에 서버 확장성이 높음
- 단점 → 클라이언트가 많은 양의 추가 데이터를 전송해야 함

**3.  비연결성**

- 클라이언트가 서버에 요청하고 응답을 받으면 TCP/IP 연결을 끊어버린다.
- 서버 리소스 효율적으로 관리, 수많은 클라이언트 요청 대응 가능

**4.  HTTP 메서드 사용**



## ✅ 소켓 통신이란?

네트워크 상에서 동작하는 프로그램 간 통신의 종착점(End Point), 접속의 끝 부분으로 운영체제가 갖고있다.

TCP/IP 통신에 사용 된다.

### 특징

**1.  양방향 통신** (클라이언트, 서버 모두 요청-응답)

**2.  연결성** : 계속 연결을 유지한다. 

- 단점 → 리소스 소모 발생

**3.  운영체제 자체 제공**

**4.  스트리밍, 실시간 채팅 등 실시간 데이터 송.수신에 유용**

### 연결 방식

IP주소와 포트번호를 넣고 연결이 되는 순간 통신이 가능하다.

(EX) 소켓 A(포트번호 5000)와 클라이언트 B, C가 있다고 가정하자.

- 다중 통신을 위해 메인소켓 (5000)은 통신 연결만을 위해 두고 새로운 스레드(5001, 5002 …)를 생성해 각자 포트에서 메세지를 주고 받는다.
- 연결상태를 유지해 부하가 크지만 새로 연결할 필요 없다.

---

# 9강 - 톰켓이란 무엇인가

### ✚ HTTP 통신

ex ) 갑의 컴퓨터에 있는 영상을 WWW로 연결 되어 있으니 을이 요청할 수 있다. 이때 갑은 웹서버이며 을이 원하는 데이터를 가지고 있다.

1. 을 → 갑에게 데이터를 받기 위해  `Request` : IP 주소 (URL) 필요
2. 갑 → 을에게 요청한 정보를 토대로 *Static자원을 `Response` 
3. 갑은 을이 요청하지 않으면 아무 것도 알 수 없음. 따라서 을의 주소를 알기 위해 연결이 지속되는 소켓을 사용

### ✚ WebServer

웹 브라우저로부터 HTTP 요청을 받아 정적인 컨텐츠를 전달

(*Static 정적파일 : html, javascript, css, image 물리적인 파일 등)

- 하드웨어에서의 웹서버
    - 웹 서버 소프트웨어와 웹 사이트의 구성 요소 파일을 저장하는 `컴퓨터` 
    (예 : HTML 문서, 이미지, CSS 스타일 시트 및 JavaScript 파일)

- 소프트웨어에서의 웹서버
    - `HTTP 서버`
        - URL(웹주소) 및 HTTP(프로토콜 주소)를 이해하는 소프트웨어
        - 저장하는 웹 사이트의 도메인 이름을 통해 액세스
        - 호스팅 된 웹 사이트의 콘텐츠를 최종 사용자의 장치로 전달

## ✅ Apache (아파치)

Apache HTTP Server

- 클라이언트에서 요청하는 HTTP요청을 처리하는 **웹서버**를 의미
- **정적타입**(HTML, CSS, 이미지 등)의 데이터만 처리 `⇒ 톰켓 등장` (제어권 넘김)

## ✅ Tomcat (톰켓)

**톰캣 WAS**(Web Application Server)

- 정적타입만 처리 가능한 아파치 서버와는 다르게
 DB연결, 다른 응용프로그램과 상호 작용 등 동적인 기능 사용 가능
1. 자바 서블릿 실행해  .jsp 파일을 읽어들인다.
2. 읽어들인 동적 파일을 컴파일 한다.
3. 컴파일 된 결과를 html 문서로 재구성 한다.
4. 재구성 된 html 문서를 아파치에게 돌려주고 아파치는 서버에 응답(response) 한다.


---

# 10강 - 서블릿 객체의 생명주기가 궁금해요

## ✅ 서블릿 컨테이너 (톰켓)

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%E1%84%87%E1%85%AE%E1%84%90%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20c84c6c5eeef2457db2ed9849025f3929/Untitled.png)

클라이언트가 요청하면 서블릿컨테이너 (톰켓)이 요청을 받고 객체를 생성한다.

클라이언트의 최초요청이 아닐 시, 이미 생성된 객체를 재사용 한다. 

정적인 파일 (html, css, png 등)을 요청하게 되면 톰켓이 아닌 어파치가 일을 한다.

하지만 스프링은 정적인 파일, URL(자원접근)과 같은 특정한 파일을 요청할 수 없다.

스프링은 URI(식별자 접근) 통해 요청을 해야하는데, 요청시에는 무조건 자바를 거쳐하며 자바는 톰켓이 제어하기 때문에 아파치의 통제권이 톰켓에게 넘어간다. 

`→  URL 구조 : [http://naver.com /](http://naver.com/)a.png`

`→  URI 구조 :  [http://naver.com](http://naver.com/picture/a) /picture/a` 

## ✅ 서블릿 컨테이너의 객체 생성 방식

```markdown
[1] 클라이언트 : 최초 요청 (First Request)
		
		(1) Java 자원 -> 서블릿컨테이너 (톰켓) 실행
						(정적 자원 -> 아파치 실행)
				
				
		(2) 서블릿 객체 생성 <new!>
		
				(2-1) init() : 초기화 호출
				
				(2-2) 스레드1 생성
							(2-2-1) Service() : 서비스 호출 
										(-> Post, Get, Put, Delete)
				(2-3) get() : DB연결, 데이터 응답 등 
				
				
[2] 클라이언트 : 최초 요청이 아닐 때 (Re -Request)

		(1) Java 자원 -> 서블릿컨테이너 (톰켓) 실행
		
		(2) 서블릿 객체 <재사용!> ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ 
		|
		|		(2-1) 스레드2 생성 
		|					(2-2-1) Service() : 서비스 호출 
		|								(-> Post, Get, Put, Delete)
		|								                        
		|		(2-3) get() : DB연결, 데이터 응답 등 
		|
		 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ 
```

<aside>
<img src="https://www.notion.so/icons/forward_gray.svg" alt="https://www.notion.so/icons/forward_gray.svg" width="40px" /> EX) 톰켓 기본 설정에 있는 스레드를 Auto로 설정했을 때 스레드 20개까지 생성이 가능하고, 
Class A 내부에 hello() 메서드가 생성되어 있다. 

(스레드 개수는 컴퓨터 성능에 따라 달라진다.)

</aside>

⇒ 
new 메서드 생성 시 hello() 메서드가 heap에 뜨게 된다.

각각의 스레드가 요청으로 메서드를 "호출" 하게 되면 메서드들은 독립적으로 매서드 스택 공간에 각각 저장된다. 

### `서블릿 객체가 하나만 있어도 각각의 스레드가 독립적으로 호출해 사용할 수 있기 때문에
 서블릿 객체 재사용이 가능한 것이다!`

스레드가 종료하는 시점 =  Response 받은 시점

⇒ 만일 20개의 스레드가 다 생성이 되고 21번째 스레드가 생성 되려면, 다른 스레드가 종료하기를 대기한다.

이때, 스레드 1이 종료하게 되면, 메모리에서 날리지 않고 21번째 스레드가 스레드1을 재사용 한다. = `Pooling 기법`

### 

## ✅ 서블릿 객체 생명주기 정리

< 최소 생성 > 

1. Request
2. 서블릿 객체 생성
3. 필요한 메서드 호출 (get(), Post() 등등)
4. 스레드 1 생성
5. Response
6. 스레드 1 제거하지 않고 재사용 대기.

< 재사용 >

1. 클라이언트의  25명 동시 접근 Request
2. 필요한 메서드 호출 (get(), Post() 등등)
3. 스레드 2~20 생성
4. 만들어둔 스레드 1은 재사용하고, 나머지 5명 대기
5. Response
6. 나머지 5명은 완료된 스레드 재사용

### ✚ Pooling + Scale-Up + Scale-Down

- Pooling
- Scale-Up
    - 기존 서버 사양 업그레이드 → 시스템 확장
- Scale-Down
    - 서버 여러대 추가 → 시스템 확장


