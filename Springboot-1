인프런 Springboot 개념정리 1
[https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/dashboard]

1. Framework : 틀 안에서 동작

2. 오픈소스 (공개된 소스), 내부를 고칠 수 있다 = 기여

3. IoC Inversion of Controll (Spring이 객체를 제어) Container
    Class : 추상적                        ex) 캐릭터 
    Object : 실체화가 가능한 것 ex) 오리아나, 티모..
    Instance : 실체화 된 것         ex) 협곡에 뛰어다니는 오리아나

    <기존>
    개발자가 직접 new를 사용해서 heap에 객체를 넣어준다
    <Spring>
    Spring이 개발자가 원하는 객체를 “직접” 탐색(scan)해서 “직접” heap 메모리에 넣어준다

    ex)
        public class Main {
        public static void main2(String[] args) {
            HelloWorld hello = new HelloWorld();
            hello.setMessage("hello world!!");
            System.out.println(hello.getMessage());
        }

        public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
            HelloWorld hello = (HelloWorld)context.getBean("helloWorld");
            System.out.println(hello.getMessage());
        }
    }
    // main2 : 개발자가 직접 new를 이용해서 객체를 생성
    // main : beans.xml 을 읽어서 xml 안에 저장된 “helloWorld” bean을 객체화

    <차이점>
    기존의 방법에서 hello world!! 의 문자열을 바꾸려면
    .java → .class → 실행파일 로 컴파일이 되는 과정이 필요하다

    반면, Spring을 사용하면 beans.xml에 저장된 bean의 value값만 변경 후, java파일에 넣으면 된다
    즉, java 파일이 수정되는 일은 없다

    +추가
    contianer?
    → 개발자 대신 객체의 생서과 소멸을 전담하는 역할
    bean?
    → Spring 컨테이너에 의해 생성, 관리되는 객체

    4. DI Dependency Injection
    실행하려는 소스코드 “밖”에서 정의된 객체를 받아서 실행하는 구조
    == 개발자가 new를 사용해서 직접 객체를 만들지 않고, 외부에서 생성된 bean(객체)를 IoC 컨테이너가 넣어줌
    ∴ IoC & DI를 이용한 코딩을 하면, 개발자가 어느 메소드에서 객체를 사용하던 같은 객체를 사용할 수 있다.

    그럼 DI를  사용하려면 객체가 있어야하네? 매우 맞음ㅇㅇ
    DI 방법
    1. 스프링을에서 의존성 주입 : xml 이용 / Java코드에서 @annotation 사용
    2. DI 사용 : 생성자 / Setter
