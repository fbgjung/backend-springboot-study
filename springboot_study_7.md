### 스프링부트 개념정리 7강 - OOP 관점에서 모델링이란 무엇일까요?

#

### JPA란

- JPA는 Java Persistence API 이다.
    - Persistence(영속성) : 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다.
    - JPA : 자바에 있는 데이터를 DB(영구)에 기록할 수 있는 환경을 제공하는 API이다.
    - API(Application programming interface) : 정의 및 프로토콜 집합을 사용하여 두 소프트웨어의 구성 요소가 서로 통신할 수 있게 하는 규칙
    - 프로토콜과 인터페이스 차이 (모두 규칙이다.)
        
        인터페이스 : 한 사람이 규칙(인터페이스)을 정하면 사용하는 사람은 규칙(인터페이스)을 따라야 한다. (상하관계가 존재하는 약속)
        
        프로토콜 : 서로 동등한 관계의 약속이다. 모두 동의할 수 있는 규칙(프로토콜)을 사용한다.
        
    - (정리) JPA는 JAVA 프로그래밍을 할 때 영구적으로 데이터를 저장하기 위해 필요한 인터페이스이다.
- JPA는 ORM 기술이다.
    - ORM(Object Relational Mapping) : Object를 데이터베이스에 연결하는 방법이다.
    - 모델링 : 추상적인 개념(클래스)을 현실 세계에 구현하는 것이다.
    - DB 테이블에 데이터를 저장, 변경, 조회, 삭제 하는 행위는 DML(Delete, Update, Insert)을 사용한다. 이때 자바와 DB의 데이터 타입이 다르므로 자바에서 클래스를 통하여 DB의 테이블을 모델링한다.
    - ORM은 클래스를 먼저 만들고 데이터베이스를 자동 생성할 수 있다. 이때 필요한 것이 JPA의 인터페이스이다.
- JPA는 반복적인 CRUD 작업을 생략하게 해준다.
    - DML은 자주 반복적으로 일어난다.
    - 데이터 입력, 변경, 삭제, 조회 과정
        1. 자바에서 DB로 커넥션 연결 요청
        2. DB가 세션을 오픈한다.
        3. 두 번째 요청 시 쿼리를 전송한다.
        4. DB는 작업을 수행하여 Data를 자바에 응답한다.
        5. 자바는 응답받은 Data와 가지고 있는 데이터 타입이 다르므로 데이터타입을 받아서 Java Object로 변경해야 한다.
    - JPA는 CRUD 일련의 작업을 함수로 제공해 주어 데이터 CRUD 처리 과정을 줄여준다.
- JPA는 영속성 컨텍스트를 가지고 있다.
    - 영속성 : 어떤 데이터를 영구적으로 저장하게 해주는 것
        
                     (자바에서는 데이터를 영구적으로 저장할 때 데이터베이스를 사용한다.)
        
    - 컨텍스트(context) : 대상의 모든 정보를 가지고 있는 것
    - 영속성 컨텍스트 : 자바가 데이터베이스에 데이터를 저장할 때 필요한 모든 데이터를 알고 있다.
    - 데이터 저장 방법 : 자바에서 데이터를 영속성 컨텍스트로 전달 → 영속성 컨텍스트는 DB에 전달 → DB에 데이터 저장
    - 영속성 컨텍스트 데이터(Java Object)와 DB 데이터(DB type)는 동기화가 된다.
        
        (영속성 컨텍스트 데이터 삭제 후 DB에 전달하면 DB 데이터 삭제)
        
- JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)
    - DB의 특징 : 각 컬럼은 데이터 타입이 기본타입이다. (Object를 가지지 못한다.)
    - 자바는 Object를 저장할 수 있다. (Class Player { int id; String name; Team team; } )
    - ORM을 사용하면 Object를 저장할 수 있는 자바가 주도권을 가진 모델을 만들 수 있다.
        
        (JPA를 통해서 Object 타입을 기본 타입(참조키)으로 자동으로 변경하여 저장한다.)
        
- JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)
    - Car 클래스는 Engine 클래스를 상속 받을 수 없고 컴포지션(결합)해야 한다.
        
        ```jsx
        Class Car { String name; String color; Engine engine; }
        ```
        
        JPA는 자바의 클래스를 토대로 아래와 같이 테이블을 자동 생성해 준다.
        
        Car 테이블
        
        | id | name | Color | engineId |
        | --- | --- | --- | --- |
        | 1 | BMW | white | 2 |
        | 2 | sonata | black | 1 |
        
        Engine 테이블
        
        | id | power |
        | --- | --- |
        | 1 | 2000 |
        | 2 | 4000 |
    - 동일한 필드가 반복적으로 사용되면 클래스에 필드로 저장하여 모든 곳에서 상속하여 사용하면 된다.
        
        ```jsx
        Class EntityDate { // 해당 필드가 필요한 클래스에 상속하여 사용
        	// 반복되어 사용되는 필드
        	TimeStamp CreateDate;
        	TimeStamp updateDate;
        }
        ```
        
- 방언 처리가 용이하여 Migration하기 좋다. (유지보수에도 좋다.)
    - DB 접근 방법 : 스프링 → JPA → DB
    - JPA는 여러 dialect를 지원하므로, DB 종류가 변경되어도 동일한 코드를 사용 가능하다.
- JPA는 쉽지만 어렵다.

#

### 상속

- 상위 클래스에 중복 로직을 구현하고 이를 상속받아 코드를 재사용하는 방법이다.
- 새로운 클래스는 기존 클래스의 필드와 메소드를 상속받아 사용할 수 있으며, 이를 확장하여 새로운 기능을 추가할 수 있다.
- 상속은 is-a 관계를 나타내며, 상위 클래스와 하위 클래스의 관계를 나타낸다.
    
    ```jsx
    public class human extends animal{
    	//... do something
    }
    ```
    

### 컴포지션

- 중복되는 로직들을 갖는 객체를 구현하고, 이 객체를 주입받아 중복 로직을 호출함으로써 인터페이스를 재사용하는 방법이다.
- 객체 안에 다른 객체를 포함하고 있는 일종의 has-a 관계를 표현한다.
- **컴포지션을 이용하면 객체의 내부는 공개되지 않고 인터페이스를 통해 코드를 재사용하기 때문에 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 결합도를 낮출 수 있다.**
    
    ```jsx
    public class House {
    	private Bedroom bedroom;
        private LivingRoom livingRoom;
        //.. do something
    }
    ```
    

### 상속(Inheritance)보다 합성(Composition)을 사용해야 하는 이유

- 상속의 한계점
    - 캡슐화가 깨지고 결합도가 높아진다.
        
        상속을 이용하기 위해서는 부모 클래스를 기반으로 코드를 재구성해야 하기 때문에 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 또한, **자식 클래스에서 super()를 이용하여 부모 클래스의 메소드를 호출하는 상황이라면 부모 클래스의 구현은 자식 클래스에게 노출되어 캡슐화가 약해지고, 자식 클래스와 부모 클래스는 강하게 결합되어 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 가능성이 높아진다.** 
        
    - 유연성 및 확장성이 떨어진다.
        
        상속은 부모 클래스와 자식 클래스가 강하게 결합되므로 변경에 대한 범위가 커지므로 유연성과 확장성이 떨어진다.
        
    - 다중상속에 의한 문제가 발생할 수 있다.
        
        자바는 다중 상속을 허용하지 않으므로, 상속이 필요한 클래스가 다른 클래스를 이미 상속중인 문제가 발생할 수 있다.
        
    - 클래스 폭발 문제가 발생할 수 있다.
        
        자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것 뿐이다.
        
- 합성을 사용해야 하는 이윺
    - 구현을 효과적으로 캡슐화 할 수 있다.
    - 의존하는 객체를 교체하는 것이 비교적 쉬우므로 설계가 유연해진다.

### 연관관계

- 방향(Direction) : 단방향 / 양방향 (방향은 객체관계에서만 존재한다.)
- 다중성(Multiplicity) : 다대일, 일대다, 일대일, 다대다
- 연관관계 주인(Owner) : 객체 관계를 양방향 연관관계로 만들면 주인을 정해야 한다.

### 단방향 연관관계

- 다대일(N:1) 단방향 관계 : 회원과 팀 (회원은 하나의 팀에만 소속)
- 테이블에서는 회원 테이블에 TEAM_ID 외래키로 테이블과 양방향 연관관계를 맺는다.
    
    ```jsx
    select *
    from member m
    join team t on m.team_id = t.id
    
    select *
    from team t
    join member m on t.team_id = m.id
    ```
    
- 회원 객체에 team 필드(멤버변수)로 팀 객체와 단방향 연관관계를 맺는다. (회원은 team 필드로 팀을 알 수 있지만 팀은 회원을 모른다.)
    
    ```jsx
    @ManyToOne
    Team team;
    ```
    

### 연관관계의 주인

- 객체간 양방향 연관관계를 만들려면 양쪽에 필드를 참조하여 단방향 연관관계 2개를 만들어야 한다. 이때 참조는 2개이지만 외래키는 하나가 되므로 두 객체의 연관 관계 중 하나가 외래키를 관리해야 한다. 외래키를 관리하는 객체가 연관관계의 주인이 된다. (연관관계 주인 테이블에 외래키가 생기는 구조로 왜래키를 관리한다.)
- 연관관계의 주인은 mappedBy  속성으로 지정한다.
    - 주인은 mappedBy 속성을 사용하지 않는다.
    - 주인이 아니면 mappedBy 속성으로 연관관계의 주인을 지정해야 한다.
    
    ```jsx
    @OneToMany(mappedBy=“team”)
    List<Member> members;
    ```
    

#

### 참조

<a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC">스프링부트 개념정리(이론)</a><br>
<a href="https://mangkyu.tistory.com/199">[OOP] 코드의 재사용, 상속(Inheritance)보다 합성(Composition)을 사용해야 하는 이유</a><br>
<a href="https://velog.io/@vino661/상속과-컴포지션에-대해서">[Java] 상속(inheritance)과 컴포지션(composition)에 대해서</a><br>
<a href="https://engineerinsight.tistory.com/28">[JAVA] 컴포지션(Composition): 조합이 뭘까? 컴포지션의 개념/사용, 상속을 사용한 코드를 조합을 사용한 코드로 바꿔보기!</a><br>
<a href="https://gist.github.com/QuadFlask/cb73933026d86c081e09184ee1f470bd">jpa.md</a><br>
