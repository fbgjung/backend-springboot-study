# 학습 내용
1강. 스프링의 핵심은 무엇인가요?

2강. 필터란 무엇인가요?

3강. 메시지 컨버터가 무엇인가요?



# 1️⃣ 스프링의 핵심은 무엇인가요?

## 1.1 스프링은 프레임워크이다.
## 1.2 스프링은 오픈소스이다.
스프링은 소스코드를 공개한다. 즉 내부를 뜯어고칠 수 있다.

## 1.3 스프링은 `IoC(Inversion of Control) 컨테이너`를 가진다.
#### 기존의 객체 생성 및 실행

1. 객체 생성
2. 클래스 내부에서 의존성 객체 생성
3. 의존성 객체 메소드 호출

#### 스프링에서의 객체 생성 및 실행: 불필요한 heap 메모리 사용 x

1. 객체 생성
2. 의존성 객체 주입: 스스로가 만드는 것이 아니라 **제어권을 스프링에게 위임하여** 스프링이 만들어놓은 객체를 주입한다.
3. 의존성 객체 메소드 호출

## 1.4 스프링은 `DI(Dependency Injection)`를 지원한다.
객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식으로, 스프링이 관리하는 객체를 내가 원하는 모든 곳(클래스의 메소드)에서 객체를 가져와서 사용할 수 있다.
    
`싱글톤 패턴` : 사용자가 여러 번 객체 생성을 하더라도 클래스로부터 오직 하나의 객체(인스턴스)만 생성되도록 하는 디자인 패턴

- 클래스가 최초 한번만 메모리를 할당하고, 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴
- 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
```java
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton() {}

    public Singleton getInstance() {
        return instance;
    }
}
```
- Singleton 클래스의 기본 생성자를 private으로 설정하여 객체를 생성하지 못하도록 한다.
- 싱글톤 클래스의 객체 한 개를 메모리 영역에 고정(static) 시켜놓고, 필요하다면 getInstance() 함수를 이용해 싱글톤 객체를 넘겨준다.
- 결국 객체는 단 한개만 생성되는 것이다.

#### 의존성 주입 방법들

1. 생성자를 이용한 주입
2. Setter를 이용한 주입
3. @Autowired 어노테이션으로 주입

#### 의존성 주입 예시
```java
@Service
public class MemberService {
    private final MemberRepository memberRepository;
    
    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```
`new`를 사용하여 객체를 직접 생성하는 대신
`MemberService` 클래스의 생성자에 `@Autowired` 어노테이션을 사용하여 `MemberRepository` 의존성이 주입된다.


#### 의존성 주입을 사용하는 이유
1. 재사용성을 높여준다.
2. 테스트에 용이하다.
3. 코드를 단순화 시켜준다.
4. 사용하는 이유를 파악하기 수월하고 코드가 읽기 쉬워지는 점이 있다.
5. 종속성이 감소하기 때문에 변경에 민감하지 않다.
6. 결합도는 낮추면서 유연성과 확장성은 향상 시킬 수 있다.
7. 객체간의 의존관계를 설정할 수 있다.
###### 참고 블로그: https://devlog-wjdrbs96.tistory.com/165


## 1.5 스프링은 엄청나게 많은 필터를 가지고 있다.
톰캣에서의 필터: filter

스프링 컨테이너의 필터: 인터셉터(AOP)

## 1.6 스프링은 엄청나게 많은 어노테이션을 가지고 있다. (리플렉션, 컴파일 체킹)
`컴파일 체킹`: 에러

`어노테이션`: 주석 + 힌트, 컴파일러가 무시하지 않고 체킹을 할 수 있도록 힌트를 주는 것
- 주석: 컴파일러가 무시

#### 컴파일 체킹 예시
```java
class Aminal {
    run();
}
```
```java
class Dog extends Animal {
    @Override
    fly();
}
```
위의 경우, Dog class 컴파일 체킹시, Animal class에 fly method가 존재하지 않기 때문에 오류가 난다.

#### 스프링에서는 어노테이션을 통해 객체를 생성한다.
`@Component`: 클래스 메모리에 로딩

`@Autowired`: 로딩된 객체를 해당 변수에 집어넣음

```java
@Component
class A{...}
```
스프링은 IoC로, 해당 클래스를 읽어서 스프링이 들고있는 메모리 공간(heap 영역)에 A 클래스를 띄운다.
```java
class B {
    @Autowired
    A a;
}
```
> **참고**
>
> new를 통해 객체를 생성하면, heap 메모리 공간에 A 영역이 하나 더 생기기 때문에 객체를 직접 생성하면 안된다.
> 
>```java
> class B {
>   A a = new A();
> }
>```
heap에서 A와 동일한 객체가 떠 있는지 확인한다. 없으면 null, 있다면 heap 메모리에 있는 A가 a 변수에 들어오게 된다. (DI, 의존성 주입)
- 이때, 타입을 통해서 A를 찾는다.

스프링이 B 클래스를 읽을 때 B 클래스 내부에 어떤 것(메소드, 필드, 어노테이션)이 있는지 분석하는 기법을 `리플렉션`이라고 한다.

`리플렉션` 무엇인가를 하라고 설정할 수도 있으며 런타임시 분석된다.


# 3️⃣ 메시지 컨버터가 무엇인가요?

## 1.7 스프링은 MessageConverter를 가지고 있다. 기본값은 현재 Json이다.
한글과 영어로 데이터를 전달 할 때 우리는 이해에 어려움을 겪는다. 이때 상대방의 언어로 번역하여 데이터를 전달하는 것은 굉장히 번거롭다. 이를 위해 `중간 데이터` 역할을 하는 `MessageConverter`가 필요하다.

`JSON`은 이러한 중간 데이터 역할을 해주는 데이터 교환 형식 중 하나이며 웹 프로그래밍에서는 JSON 통신이 매우 중요하다. 웹 애플리케이션에서 클라이언트와 서버 간의 데이터 교환에 많이 사용된다. JSON 데이터들은 일반적으로 HTTP 요청 또는 응답의 바디에 포함되어 전달된다.

JSON으로 request한 파라미터들을 Java에서 받으려면 Java Object로의 변환이 필요하며, 마찬가지로 response 시에도 Java Object에서 JSON으로 변환이 필요하다.


```java
// json? key : value
{
    "age" : 10,
    "name" : "사자"
}
```
> **참고**
>
>JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 `Jackson`, `Gson`과 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다. 스프링 부트로 Spring MVC를 선택하면 기본으로 Jackson 라이브러리(ObjectMapper)를 함께 제공한다.

`스프링`에서는 이를 처리하기 위해  `HttpMessageConverter`를 사용한다. 1.8 에서 어떤식으로 활용되는지 자세히 알아본다.

## 1.8 스프링은 BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.
### 개요
**1byte**: 데이터 통신의 논리적인 최소 단위로, 물리적으로 bit 단위로 즉, `8bit(1byte)`씩 끊어서 한 문자씩 요청(응답)하게 된다. 우리는 결국 문자열을 읽고 쓴다. UTF-8이라는 1문자당 3byte로 통신하는 규약을 사용하도록 한다.

**Byte Stream** : 데이터를 1byte 단위로  입출력할 수 있는 stream이다. stream이란, 출발지와 도착지를 이어주는 다리이다.

**BufferedReader & BufferedWriter**

ByteStream을 통해서 데이터를 전송할 때, 전송 단위가 문자열로 가변 길이의 데이터를 쓰게 해주는 클래스
- `InputStream` : 자바에서 가장 기본이 되는 입출력 스트림, 1byte만 읽는다.
- `InputStreamReader` :  `InputStream`를 확장한 것으로, 바이트를 문자 단위 데이터로 type casting 해주는 중간다리 역할을한다. 배열로 여러개의 문자를 받을 시, 배열은 크기가 정해지기 때문에 크기가 작은 문자를 받을 때 메모리 낭비가 발생한다.
- `BufferedReader`: 가변 길이의 문자를 받아 메모리 낭비를 줄인다.

### 스프링의 @RequestBody & @ResponseBody
HTTP 요청의 본문을 읽기 위해 BufferedReader, 응답 본문을 쓰기 위해 BufferedWriter를 사용할 수 있지만, 스프링에서는 개발자가 쉽게 사용할 수 있도록 이를 내부적으로 `HttpMessageConverter`가 처리한다.

다양한 `HttpMessageConverter` 구현체가 있으며, 그 중 `MappingJackson2HttpMessageConverter`는 JSON 데이터를 처리하는 데 사용된다. 이는 Jackson 라이브러리를 사용하여 JSON 데이터를 자바 객체로 변환하거나, 자바 객체를 JSON 데이터로 변환한다.

이때 @RequestBody와 @ResponseBody 어노테이션이 이러한 작업들을 자동으로 처리해준다. 

<img width="550" alt="ResponseBody사용원리" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/4b0dc7a7-e957-44b9-bc53-e714e2568377">

#### Http 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법
1. GET - 쿼리 파라미터
    - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
    - ex) 검색, 필터, 페이징 등에서 많이 사용
2. POST - HTML Form
    - 메시지 바디에 쿼리 파라미터 형식으로 전달
    - ex) 회원가입, 상품 주문, HTML Form 사용
3. `HTTP message body에 데이터를 직접 담아서 요청`
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 주로 클라이언트 서버 간의 데이터 교환에서 많이 사용


일반적인 GET/POST의 요청 파라미터라면 `@RequestBody`를 사용할 필요가 없으며 XML이나 JSON 기반의 메시지를 사용하는 요청의 경우에 이 방법이 매우 유용하다.

`@RequestBody (BufferedReader)`: 해당 어노테이션이 붙은 파라미터에는 HTTP 요청 본문(body)이 그대로 전달된다. HTTP 요청의 바디 내용을 자바 객체로 변환해서 매핑된 메소드 파라미터로 전달해준다.
```http
클라이언트 요청 예시

POST /signup
Content-Type: application/json
message-body:
{
    "username": "spring",
    "password": "123"
}

```
```Java
// Object
public class User {
    private String username;
    private String password;
}

// UserController
// JSON 데이터를 User 객체로 변환
@PostMapping("/signup")
public ResponseEntity<String> signup(@RequestBody User user) {
    return ResponseEntity.ok("Success");
}
```


`@ResponseBody (BufferedWriter)`: 자바 객체를 HTTP 요청의 바디 내용으로 매핑하여 클라이언트로 전송한다. 
```java
// Object
public class User {
    private String username;
    private String password;
}

// UserController
@Controller
public class UserController{
    private User user = new User("spring", "123"); // 객체 생성 가정

    @ResponseBody
    @GetMapping("/login")
    public User findAllUser() {
        return user; // 클라이언트에게 json 형태로 반환
    }
}
```
```http
클라이언트로 응답 예시

HTTP/1.1 200 OK
Content-Type: application/json

{
    "username": "spring",
    "password": "123"
}
```
### 정리
클라이언트에서 서버로 필요한 데이터를 요청하기 위해 JSON 데이터를 요청 본문에 담아서 서버로 보내면, 서버에서는 @RequestBody 어노테이션을 사용하여 HTTP 요청 본문에 담긴 값들을 자바 객체로 변환시켜, 객체에 저장한다.

서버에서 클라이언트로 응답 데이터를 전송하기 위해 @ResponseBody 어노테이션을 사용하여 자바 객체를 HTTP 응답 본문의 객체로 변환하여 클라이언트로 전송한다. 


> **참고**
> 
> 만약 `@RestController` 어노테이션을 명시했다면 `@ResponseBody` 어노테이션을 명시하지 않아도 자동으로 HttpResponse의 본문 responseBoby에 자바 객체가 매핑되어 전달된다.
> 
> `@RestController`는 `@Controller`와 `@ResponseBody`를 합친 기능을 제공하는 것으로, `@RestController` 어노테이션이 명시되면스프링은 기본적으로 모든 메소드의 반환 값을 HTTP 응답 본문으로 처리하게 된다.
>
> 개발자가 REST API를 구현할 때 좀 더 간결하고 직관적으로 코드를 작성할 수 있도록 돕는다.

## 1.9 스프링은 계속 발전중이다. 

## 참고
[[Spring] @ResponseBody & @RequestBody 개념](https://dev-coco.tistory.com/95)

[[Spring] @ResponseBody & @RequestBody 예시](https://velog.io/@oyoungsun/Spring-RequestBody-ResponseBody)

 [김영한의 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard)