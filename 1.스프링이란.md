# 학습 내용
1강. 스프링의 핵심은 무엇인가요?

2강. 필터란 무엇인가요?

3강. 메시지 컨버터가 무엇인가요?



# 1️⃣ 스프링의 핵심은 무엇인가요?

## 1.1 스프링은 프레임워크이다.
## 1.2 스프링은 오픈소스이다.
스프링은 소스코드를 공개한다. 즉 내부를 뜯어고칠 수 있다.

## 1.3 스프링은 `IoC(Inversion of Control) 컨테이너`를 가진다.
#### 기존의 객체 생성 및 실행

1. 객체 생성
2. 클래스 내부에서 의존성 객체 생성
3. 의존성 객체 메소드 호출

#### 스프링에서의 객체 생성 및 실행: 불필요한 heap 메모리 사용 x

1. 객체 생성
2. 의존성 객체 주입: 스스로가 만드는 것이 아니라 **제어권을 스프링에게 위임하여** 스프링이 만들어놓은 객체를 주입한다.
3. 의존성 객체 메소드 호출

## 1.4 스프링은 `DI(Dependency Injection)`를 지원한다.
객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식으로, 스프링이 관리하는 객체를 내가 원하는 모든 곳(클래스의 메소드)에서 객체를 가져와서 사용할 수 있다.
    
`싱글톤 패턴` : 사용자가 여러 번 객체 생성을 하더라도 클래스로부터 오직 하나의 객체(인스턴스)만 생성되도록 하는 디자인 패턴

- 클래스가 최초 한번만 메모리를 할당하고, 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴
- 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
```java
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton() {}

    public Singleton getInstance() {
        return instance;
    }
}
```
- Singleton 클래스의 기본 생성자를 private으로 설정하여 객체를 생성하지 못하도록 한다.
- 싱글톤 클래스의 객체 한 개를 메모리 영역에 고정(static) 시켜놓고, 필요하다면 getInstance() 함수를 이용해 싱글톤 객체를 넘겨준다.
- 결국 객체는 단 한개만 생성되는 것이다.

#### 의존성 주입 방법들

1. 생성자를 이용한 주입
2. Setter를 이용한 주입
3. @Autowired 어노테이션으로 주입

#### 의존성 주입 예시
```java
@Service
public class MemberService {
    private final MemberRepository memberRepository;
    
    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```
`new`를 사용하여 객체를 직접 생성하는 대신
`MemberService` 클래스의 생성자에 `@Autowired` 어노테이션을 사용하여 `MemberRepository` 의존성이 주입된다.


#### 의존성 주입을 사용하는 이유
1. 재사용성을 높여준다.
2. 테스트에 용이하다.
3. 코드를 단순화 시켜준다.
4. 사용하는 이유를 파악하기 수월하고 코드가 읽기 쉬워지는 점이 있다.
5. 종속성이 감소하기 때문에 변경에 민감하지 않다.
6. 결합도는 낮추면서 유연성과 확장성은 향상 시킬 수 있다.
7. 객체간의 의존관계를 설정할 수 있다.
###### 참고 블로그: https://devlog-wjdrbs96.tistory.com/165


## 1.5 스프링은 엄청나게 많은 필터를 가지고 있다.
톰캣에서의 필터: filter

스프링 컨테이너의 필터: 인터셉터(AOP)

## 1.6 스프링은 엄청나게 많은 어노테이션을 가지고 있다. (리플렉션, 컴파일 체킹)
`컴파일 체킹`: 에러

`어노테이션`: 주석 + 힌트, 컴파일러가 무시하지 않고 체킹을 할 수 있도록 힌트를 주는 것
- 주석: 컴파일러가 무시

#### 컴파일 체킹 예시
```java
class Aminal {
    run();
}
```
```java
class Dog extends Animal {
    @Override
    fly();
}
```
위의 경우, Dog class 컴파일 체킹시, Animal class에 fly method가 존재하지 않기 때문에 오류가 난다.

#### 스프링에서는 어노테이션을 통해 객체를 생성한다.
`@Component`: 클래스 메모리에 로딩

`@Autowired`: 로딩된 객체를 해당 변수에 집어넣음

```java
@Component
class A{...}
```
스프링은 IoC로, 해당 클래스를 읽어서 스프링이 들고있는 메모리 공간(heap 영역)에 A 클래스를 띄운다.
```java
class B {
    @Autowired
    A a;
}
```
> **참고**
>
> new를 통해 객체를 생성하면, heap 메모리 공간에 A 영역이 하나 더 생기기 때문에 객체를 직접 생성하면 안된다.
> 
>```java
> class B {
>   A a = new A();
> }
>```
heap에서 A와 동일한 객체가 떠 있는지 확인한다. 없으면 null, 있다면 heap 메모리에 있는 A가 a 변수에 들어오게 된다. (DI, 의존성 주입)
- 이때, 타입을 통해서 A를 찾는다.

스프링이 B 클래스를 읽을 때 B 클래스 내부에 어떤 것(메소드, 필드, 어노테이션)이 있는지 분석하는 기법을 `리플렉션`이라고 한다.

`리플렉션` 무엇인가를 하라고 설정할 수도 있으며 런타임시 분석된다.