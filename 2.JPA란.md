# 학습 내용
4강. JPA란 무엇인가요?  
5강. ORM이란 무엇인가요?  
6강. 영속성 컨텍스트란 무엇인가요?  
7강. OOP 관점에서 모델링이란 무엇일까요?

# 4️⃣ JPA란 무엇인가요?
## 4.1 JPA는 Java Persistence API 이다.
### 1. 영속성
`Persistence(영속성)` : 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다. 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 구현한다.  

### 2. 프로토콜 vs 인터페이스
프로토콜과의 비교를 통해 인터페이스를 좀 더 자세히 알아보자.  
| 프로토콜 | 인터페이스 |
| ---- | ----- |
| 권리가 동등한 약속 | 상하관계가 존재하는 약속 |
| email로 연락하자 | 해당 데이터 사용을 원하면 밤 12시 ~ 새벽 6시까지!!|
| 인터넷은 수많은 프로토콜들이 모여 만들어진 것이다. |

### 2. JPA, Java Persistence API
`API`: Application Programming Interface  
`JPA`: 자바로 프로그래밍 할 때, 영구적으로 데이터를 저장하기 위해서 필요한 `인터페이스`

- Java 에서 `ORM(Object-Relational Mapping)` 기술 표준으로 사용하는 인터페이스 모음
- Java 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
- 실제적으로 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 `프레임워크`
- 대표적인 오픈소스는 `Hibernate` 구현체

### 3. 왜 JPA를 사용해야 할까?
1. 반복적인 CRUD SQL을 처리해준다.  
JPA는 매핑된 관계를 이용해서 SQL을 생성하고 실행하는데, 개발자는 어떤 SQL이 실행될지 생각만하면 된다.  
native SQL 기능도 제공해서 관계 매핑이 어렵거나 성능에 대한 이슈가 우려되는 경우 SQL을 직접 작성하여 사용할 수 있다.
2. SQL이 아닌 객체 중심으로 개발할 수 있다.  
생산성이 좋아지고 유지보수도 수월하다.
3. 패러다임의 불일치를 해결했다.  
Java에서는 상속관계가 존재하는데 데이터베이스에서는 이러한 객체의 상속 관계를 지원하지 않는다. JPA는 이를 해결하였다. 

### 4. Spring Data JPA
JPA를 더 쉽게 사용할 수 있도록 돕는 Spring 프레임워크의 확장 라이브러리  
`CrudRepository`, `JpaRepository`와 같은 인터페이스를 통해 기본적인 CRUD 작업을 간단히 수행하도록 한다. 

<img width="300" alt="스크린샷 2024-06-18 오후 7 13 42" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/a6ed948d-6f55-4fe6-9a07-5cbfa24b72f5">


# 5️⃣ ORM이란 무엇인가요?
## 4.2 JPA는 ORM 기술이다.
Object Relational Mapping: 오브젝트를 데이터베이스에 연결하는 방법론  

클래스를 통해서 데이터베이스에 있는 테이블(데이터)을 자바 세상에 모델링 해야한다. 
```java
class Team {
    int id;
    String name;
    String year;
}
```
실제 프로그래밍을 할 때는 데이터 테이블을 만들고, class를 만든다.   
역으로 바꿔버릴 수 있다. `ORM`!  
java class로 데이터베이스에 테이블을 자동생성할 수 있는데, 이때 필요한게 JPA가 가지고 있는 인터페이스!

### 1. ORM이란?
<p align="center">
  <img width="500" height="230" alt="ORM" location="center" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/c17dfa4f-d589-4a4d-9d78-0f325d912468">
</p>

객체와 관계형 데이터를 매핑하기 위한 기술이다.  
이러한 매핑이 필요한 이유는 객체 지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치가 있기 때문이다.  

### 2. 패러다임 불일치
객체 지향 프로그래밍과 관계형 데이터베이스 사이의 데이터 표현 방식이 달라서 생기는 문제를 패러다임 불일치라고 한다.  

### 3. JPA (ORM을 위한 표준 인터페이스)
개발자가 JPA를 사용하면, JPA 내부에서 JDBC API를 사용하여 SQL을 호출하여 DB와 통신한다. 즉, 개발자가 직접 JDBC API를 쓸 필요가 없다.   

### 4. Hibernate (JPA 구현체)
JPA를 구현한 프레임워크 중 사실상 표준이다. JPA는 기술 스펙이고 하이버네이트는 이 기능을 구현하여 공급해주는 역할이다.   
Hibernate는 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리해서 개발자가 일일이 SQL 쿼리를 작성하지 않도록 도와준다.  

### 5. Spring Data JPA (JPA 기반 애플리케이션 개발을 보다 간편하게 만드는 라이브러리/프레임워크)
> **고민**  
Spring으로 개발하면서 EntityManager를 직접 다뤄본 적이 왜 없을까 생각해 봤을 때, DB에 접근할 필요가 있는 대부분의 상황에서는 Repository를 정의하고 사용했기 때문이다.  
이 Repository가 Spring Data JPA의 핵심이다!!

- 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 모듈이다.  
- JPA를 사용할 때 필수적으로 생성해야하나, 예상 가능하고 반복적인 코드들을 대신 작성해줘서 코드를 줄여주는 것이다.  
- JPA를 한단계 추상화시킨 repository라는 인터페이스를 제공함으로써 이루어진다.

Spring Data JPA는 JPA provider가 아니다. 단지 데이터 계층에 접근하기 위해 필요한 뻔한 코드들의 사용을 줄여주도록 하는 인터페이스이다. 여기서 반드시 기억해야할 점은 Spring Data JPA는 항상 하이버네이트와 같은 JPA provider가 필요하다는 것이다.

사용자가 Repository 인터페이스에 정해진 규칙대로 메서드를 입력하면, Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해 준다.  

CRUD 연산, 페이징, 정렬과 같은 JPA 리포지토리를 구현하는 데 필요한 반복적인 코드 양을 줄이는 인터페이스와 클래스를 제공한다.  

### 6. `JPA` vs `Spring Data JPA`
|JPA|Spring Data JPA|
|-|-|
|EntityManager를 사용하여 데이터베이스 기능을 사용|Repository 인터페이스를 사용하여 EntityManager 대신에 사용|


## 4.3 JPA는 반복적인 CRUD 작업을 생략하게 해준다. (Spring Data JPA 예시)
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {}
```
- `JPARepository`는 `CrudRepository` 인터페이스를 상속 받는다.  
- `count`, `delete`, `deleteAll`, `deleteAllById`, `deleteById`, `existsById`, `findById`, `save` 등의 기본적인 메서드를 제공한다. 

### 1. findAll(): 모든 엔티티 조회
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public List<User> findAll() {
        return userRepository.findAll();
    }
}
```


# 6️⃣ 영속성 컨텍스트란 무엇인가요?
## 4.4 JPA는 영속성 컨텍스트를 가지고 있다.
### 1. 영속성 컨텍스트 (강의 내용 정리)  
영속성: 데이터를 database(mysql)에 영구적으로 저장하는 것  
컨텍스트(context): 대상에 대한 모든 정보를 가지고 있다.  


- `DB`에 동물 데이터를 저장하고 싶다. 다이렉트로 `DB`에 접근해서 저장하는 게 아니라, 중간에 `영속성 컨텍스트`가 있다.  
이 영속성 컨텍스트는 `Java`가 데이터베이스에 데이터를 저장해야하는 모든 것들을 알고있다. 

- `Java`가 `DB`에 데이터를 저장하고 싶으면, `영속성 컨텍스트`에 동물 데이터를 던진다. `영속성 컨텍스트`는 `DB`에 동물 데이터를 던진다.  
이때 `영속성 컨텍스트` 안의 데이터와 `DB`안의 데이터는 동기화가된다.  


- 과일데이터의 `사과` 데이터를 `딸기`로 변경할 때, 영속성 컨텍스트에 있는 과일데이터가 `딸기`로 변한다.  
그리고 DB에 변경된 데이터를 밀어넣으면 `Update`가 자동으로 호출된다. 

- `Java`가 `DB`에 데이터를 저장하고, `DB`의 데이터를 가져오고하는 일련의 모든 정보를 영속성 컨텍스트를 통해 확인할 수 있다.  

- 영속성 컨텍스트에서 일어나는 모든 일은 `자동으로` 처리된다.  

### 2. 엔티티
데이터베이스의 테이블과 매핑되는 객체를 의미한다.  
객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체이다.

### 3. 엔티티 매니저
엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 한다.  
```java
//스프링부트가 엔티티 매니저를 사용하는 방법

@PersistenceContext
EntityManager em;
```

### 4. JPA의 특징 영속성 컨텍스트
엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다.  
이를 통해 데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있다.  
엔티티매니저가 관리하는 엔티티의 집합이다.  



### 5. Spring data JPA에서의 영속성 컨텍스트
위에서 다룬 엔티티 매니저는 Spring Data JPA에서 관리하므로 개발자가 직접 생성하거나 관리할 필요가 없다.  
내부적으로 entityManager를 사용하여 영속성 컨텍스트를 관리하고, 데이터베이스와의 상호작용을 처리한다. 

## 4.5 JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)


<img width="500" alt="45" src="https://github.com/fbgjung/studyAlgorithm/assets/104186871/cbf63f9e-a916-4ea7-9a52-0d4b9c1575c8">  

이대호는 1이라는 Integer 데이터를 가지는 것이지 Team 테이블의 Id, Name, Year 오브젝트 정보를 통으로 가지지는 못한다.  
자바의 관점에서 보면,  

```java
class Team {
    int id;
    String name;
    String year;

}
```
```java
class Player {
    int id; // 2
    Strin name; // 공필성
    int teamId; // 1 // 이대로 던지면, 공필성이라는 사람이 어느 팀에 있는지는 알 수 없다.
}
```
두번의 `Select`를 하던지, `JOIN`을 통해서 해결해야한다.  

자바는 오브젝를 저장할 수 있기 때문에 `Team team`으로 선언할 수 있다. 진정한 OOP

`ORM`을하게되면 `model`을 만들때 자바가 주도권을 쥐고있는 모델을 만들 수 있다.  
- 이런식으로 들어간 데이터를 INSERT, SELECT할 때 JPA가 자동으로 매핑 해서 데이터를 객체에 쏙! 넣어줄 것이다. 이런일을 해주는게 ORM이다.


따라서 ORM을 통해 DB와 OOP의 불일치성을 해결할 수 있다. (DB는 객체 저장이 불가능하지만 자바는 가능하다.)  
자바에서 프로그래밍할 때는 객체로 저장하고 이것을 DB에 밀어넣을 때는 JPA가 자동으로 FK를 집어넣어 주는 것이다.

# 7️⃣ OOP 관점에서 모델링이란 무엇일까요?
## 2.6 JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)

### 1. 컴포지션(Composition)
 
Car에 Engine의 속성을 사용하고 싶다. extends Engine을 하면 되지 않을까?  
상속은 객체 지향 프로그래밍에서 `is-a` 관계를 나타낸다. 즉, 자식 클래스는 부모 클래스의 일종이어야 한다.   
Car extends Vehicle : 합리적임  
Car extends Engine : 합리적이지 않음 

Car와 Engine의 관계는 `has-a` 관계로 Car은 Engine을 `가지고있다.` 따라서 컴포지션을 사용하는 것이 적절하다. 

```java
class Car {
    int id;
    String name;
    String color;
    Engine engine;
}
```

```java
class Engine {
    int id;
    int power;
}
```

JPA는 클래스를 먼저 만들고 클래스를 토대로 DB table을 자동생성한다.  
클래스 안에 객체가 존재하면, 객체 테이블을 또하나 만든다. 

#### Car 테이블
|id|name|color|EngineId|
|:-:|:-:|:-:|:-:|
|1|BMW|white|2|
|2|sonata|black|1|
#### Engine 테이블
|id|power|
|:-:|:-:|
|1|2000|
|2|4000|

DB 테이블은 객체를 자료형으로 사용할 수 없기 때문에 자동으로 `Composition 관계는 FK로 연결해준다.` -> 컴포지션 처리

#### MySQL 데이터베이스로 표현하려면 
```sql
CREATE TABLE Car (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    color VARCHAR(50),
    engine_id INT,
    FOREIGN KEY (engine_id) REFERENCES Engine(id);
)
```
```sql
CREATE TABLE Engine (
    id INT PRIMARY KEY AUTO_INCREAMENT,
    power INT NOT NULL
)
```
> **결론**  
`Car` 클래스를 통해서 `Car`, `Engine` 테이블이 자동 생성되는 것이다.


### 2. 상속
JPA는 관계형 데이터베이스에서 허용하지 않는 상속을 허용한다.  
```java
class Car extends EntityDate {
    int id;
    String name;
    String color;
    Engine engine;
}
```

```java
class Engine extends EntityDate {
    int id;
    int power;
}
```

```java
class EntityDate {
    TimeStamp = createDate;
    TimeStamp = updateDate;
}
```
#### Car 테이블
|id|name|color|EngineId|createDate|updateDate|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|BMW|white|2|||
|2|sonata|black|1|||
#### Engine 테이블
|id|power|createDate|updateDate|
|:-:|:-:|:-:|:-:|
|1|2000|||
|2|4000|||

### 3. 상속 전략 3가지
`@Inheritance(strategy = InheritanceType.XXXX)`: 상속관계 매핑 방법을 선택한다.  
- JOINED, SINGLE_TABLE, TABLE_PER_CLASS   

`@Discriminataorcolumn(name = "DTYPE")` : 부모 클래스에서 자식 클래스를 구분하는 컬럼의 이름을 설정한다.  
`@DiscriminatorBalue("XXX")` : 자식 클래스를 식별하기 위해 부모의 DTYPE 컬럼에 저장될 값을 설정한다.
- 기본 값은 클래스 이름이다.

### `JOINED` 전략: 각각의 테이블로 변환
<img width="500" alt="조인전략" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/6446fef2-8152-45d7-a478-38f5a3369a9d">  

엔티티 각각을 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아 기본키+외래키로 사용하는 전략  
- 부모 및 자식 클래스가 정의된 그대로 만들어진다. 
- 부모 클래스에는 자식 클래스 구분을 위한 DTYPE, 자식 클래스엔 JOIN을 위한 ITEM_ID 컬럼이 생성된다.

- 가장 정규화 된 방법으로 구현하는 방식이다.
- NAME, PRICE가 ITEM 테이블에만 생성되고, ALBUM, MOVIE, BOOK이 각자의 데이터만 저장한다.
- hibernate 조인 전략에서는 @DiscriminatorColumn을 선언하지 않으면 DTYPE 컬럼이 생성되지 않는다.
- JOIN 하면 ALBUM인지 MOVIE 인지 알 수 있지만 DTYPE을 넣어주는 것이 명확하다.

```java
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public class Item {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
}

@DiscriminatorValue("BOOK")
public class Book extends Item {
    private String author;
    private String isbn;
}
```

- Movie 객체를 저장하면?
    - INSERT 쿼리가 두개 나가서 Item, Movie 테이블에 저장된다.
```java
Movie movie = new Movie();
movie.setDirector("감독A");
movie.setActor("배우B");
movie.setName("분노의질주");
movie.setPrice(35000);
​em.persist(movie);
```

```sql
Hibernate:     
/* insert advancedmapping.Movie        */ 
insert         
into            
    Item            
    (id, name, price, DTYPE)         
values            
    (null, ?, ?, 'Movie')

Hibernate:     
/* insert advancedmapping.Movie        */
insert         
into            
    Movie            
    (actor, director, id)         
values            
    (?, ?, ?)
```
### `SINGLE_TABLE` 전략: 통합 테이블로 변환
<img width="500" alt="싱글테이블" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/ecff7c29-df6b-452a-9471-e732df386d73">

자식클래스의 모든 속성들을 다 부모 클래스에 넣은 테이블을 생성한다.  
- 서비스 규모가 크지 않고, 굳이 조인 전략을 선택해서 복잡하게 갈 필요가 없다고 판단 될 때 선택
- INSERT, SELECT 쿼리 모두 한 번만에 이루어진다. 
- 성능이 좋다.
- @DiscriminatorColumn을 선언해 주지 않아도, 기본으로 DTYPE 컬럼이 생성된다. 
- 한 테이블에 모든 컬럼을 저장하기 때문에, DTYPE 없이는 테이블을 판단할 수 없다.

```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public class Item {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
}

@DiscriminatorValue("BOOK")
public class Book extends Item {
    private String author;
    private String isbn;
}
```

- Item 테이블을 조회한다.
- DTYPE을 검색 조건으로 추가해서 Movie 조회
```sql
Hibernate:     
select        
    movie0_.id as id2_0_0_,        
    movie0_.name as name3_0_0_,        
    movie0_.price as price4_0_0_,        
    movie0_.actor as actor8_0_0_,        
    movie0_.director as director9_0_0_     
from        
    Item movie0_     
where        
    movie0_.id=?         
    and movie0_.DTYPE='Movie'
```

### `TABLE_PER_CLASS`전략: 서브타입 테이블로 변환하는 구현 클래스마다 테이블을 생성
<img width="500" alt="TABLE_PER_CLASS" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/769bb14c-c3a9-40ca-948d-f5b29c08a008">

조인 전략과 유사하지만, 슈퍼 타입(Item)의 컬럼들을 서브타입으로 내린다.  
- NAME, PRICE 컬럼들이 중복되도록 허용하는 전략이다.  

```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public class Item {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
}

@DiscriminatorValue("BOOK")
public class Book extends Item {
    private String author;
    private String isbn;
}
```

> **알 수 있는 점**  
strategy만 변경하면 테이블 구조의 변동이 일어난다. 만약 JPA를 사용하지 않는다면 테이블 구조의 변경이 일어날 때 코드를 많이 손봐야 할 것이다.
 

### `@MappedSuperclass` vs `TABLE_PER_CLASS`
> **고민**  
Car, Engine 예시는 TABLE_PER_CLASS 전략인가?

- TABLE_PER_CLASS : 슈퍼클래스를 기준으로 쿼리할 때, UNION을 사용하여 결과를 결합
- @MappedSuperClass : 슈퍼클래스가 엔티티가 아니므로 직접 쿼리할 수 없다. 따라서 각 하위 클래스를 쿼리해야 한다.


## 2.7 방언 처리가 용이하여 Migration 하기 좋음. 유지보수에도 좋음.
JPA는 특정 DB를 지정해놓지 않고, 추상화 객체를 두고 Oracle, Mysql, MariaDB, Portgres 등 어떤 종류가 와도 상관없도록 지원한다. 

- MySQL과 PostgreSQL은 문법에서 약간 차이가 있지만, JPA가 이를 추상화하여 개발자가 특정 DB에 종속되지 않고 표준 JPA 쿼리를 사용할 수 있게 한다.

## 2.8 JPA는 쉽지만 어렵다.


 ## 참고
 [[Spring JPA] JPA란? ](https://dbjh.tistory.com/77)

[[Spring JPA] Spring Data JPA 이해하기 (feat ORM, JPA)](https://doing7.tistory.com/105)  
[[Spring JPA] JPA와 Spring data JPA 차이점 (+ Hibernate)](https://lealea.tistory.com/238)  
[[JPA] JPARepository에 대해 알아보자(+사용법, Method)](https://velog.io/@minju0426/JPARepository%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90%EC%82%AC%EC%9A%A9%EB%B2%95-Method)

[[JPA, 엔티티 메니저, 영속성 컨텍스트] 스프링 데이터 JPA, 5분 만에 알아보기](https://yozm.wishket.com/magazine/detail/2160/)

[[JPA 상속] 상속관계 매핑 전략(@Inheritance, @DiscriminatorColumn)](https://ict-nroo.tistory.com/128)  
[[JPA 상속] 상속관계 매핑](https://devjaewoo.tistory.com/134)