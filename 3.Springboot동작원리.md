# 학습 내용
8강. HTTP가 무엇일까요? 정확히 알아야 해요  
9강. 톰캣이란 무엇인가요?
10강. 서블릿 객체의 생명주기가 궁금해요!

# 8️⃣ HTTP가 무엇일까요? 정확히 알아야 해요
## 3.1 내장 톰켓을 가진다.
### `TCP & HTTP`
TCP 통신과 HTTP 통신이란 해당 계층에 해당되는 규약(protocol)아래에서 이루어지는 통신을 의미한다.  
TCP 통신: 
- 양방향 통신, 소켓을 이용한 연결 방식을 사용한다.  
-  양방향 통신으로 클라이언트단과 서버단의 연결이 끊어지지않고 계속 연결을 유지해주어 실시간 소통이 가능하다.   

HTTP 통신: 
- 단방향 통신
- HTTP는 TCP에 기반하여 만들어졌기 때문에, HTTP 통신 또한 소켓 기반이다. 
- HTTP 통신은 클라이언트의 요청이 왔을때만 서버단이 응답하고 처리를 해주며 해당 응답이 끝나면 연결을 바로 끊게 된다.  
- 연결을 지속시키지 않고 끊어버리는 `stateless` 방식을 사용한다.  
 

소켓을 이용한 연결은 TCP 프로토콜 기반으로 맺어진 연결이며, 소켓 통신이라고도 부른다.  

### `소켓`
네트워크를 서로 연결하는 연결부 같은 역할을 한다.   
방식에 따라 TCP 소켓과 UDP 방식으로 나뉜다.  
OSI 7 Layer의 네 번째 계층인 TCP 상에서 동작하는 소켓을 주로 사용하는데, 이를 TCP 소켓이라고 부른다.  
운영체제가 가지고 있는 것이다.

### `소켓연결`
TCP/IP 프로토콜 기반으로 맺어진 네트워크 연결이며, 소켓통신이라고도 부른다.
일반적으로, 서버는 특정 컴퓨터 위에서 돌아가고 특정 포트넘버에 할당된 소켓을 갖는다.  
이 서버는 클라이언트가 커넥션 요청을 만들기 위한 소켓을 리스닝하며 기다린다.  
클라이언트쪽에서 커넥션이 성립된 경우, 소켓이 성공적으로 생성되며 클라이언트는 소켓을 서버와 상호작용하기 위해 사용할 수 있다.  

네트워크 위에서 돌아가는 두 프로그램 간의 양방향 통신 링크의 엔드포인트다.  
소켓은 포트 넘버를 할당받아 TCP 레이어가 데이터의 목적지인 애플리케이션을 식별하도록 한다.  
엔드포인트는 IP 주소와 포트넘버의 조합이다.

즉 IP와 포트 넘버를 활용하여 만들어진 통신의 양끝단이다.  

### `소켓 프로그래밍`
Server와 Client가 특정 Port를 통해 연결을 유지하고 있어 실시간으로 양방향 통신을 하는 방식이다.  
실시간 스트리밍 중계나 실시간 채팅과 같이 즉각적으로 정보를 주고받는 경우에 사용한다.  


### `HTTP 통신`
HTTP 통신은 TCP 위에서 이루어진다.  
즉 HTTP 또한 소켓 통신을 활용한 방식이라고 볼 수 있다. !!!!  
HTTP 통신은 TCP 통신 기반에서 데이터를 전송하는 부분만 맡아서 역할을 한다.  
HTTP 통신을 하기위해서는 OSI 계층에서 TCP 기반인 4계층에서 3-way-handshake로 연결 과정을 거치고 7계층에서 HTTP 기반으로 데이터 전송을 하고 다시 4계층에서 4-way-handshake로 연결을 끊는 과정을 거쳐야 한다.  

특정 웹페이지를 들어가기 위해 브라우저에 naver.com을 입력하면 서버단에 요청이 들어오고 naver.com에 해당하는 내용들을 브라우저(클라이언트)에게 보내고 연결이 끊기면서 끝난다.

데이터 전송에 사용되는 소켓의 통신 방식이 TCP 통신의 데이터 전송에서 사용되는 소켓 통신과는 다른 방식으로 사용이된다.  

REST API도 HTTP 통신에 해당한다.  

### `HTTP 프로그래밍`
html 파일을 전송하거나, JSON, image 파일 등을 전송하는데 사용된다.  


### `소켓 통신 예시`
A,B가 메시지를 교환하기 위해서 운영체제가 제공하는 소켓을 이용하면 된다.  
A가 포트번호를 열고 소켓을 연다. 
이때, B가 A와 통신하고 싶으면 A의 IP주소와 포트번호를 넣으면 연결이된다.  
C가 A와 메시지를 교환하고 싶은데 B가 5000번 포트로 소켓와 연결되어 있기 때문에 C가 5000번으로 연결할 수 있는 방법이 없다.  
<img width="500" alt="소켓통신" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/dc8fdf95-7cc6-4bbd-a381-d7c6dd29758f">  

최초에 5000번 포트는 연결의 용도로만 사용한다. 5000번 포트가 연결되는 순간 새로운 소켓을 만든다.  
5001번(랜덤) 포트로 소켓이 만들어지고, 5000번 포트는 연결이 끊기고 5001 포트로 연결된다.  
5001번의 새로운 소켓을 만들 때는 새로운 스레드를 하나 만든다.

main 스레드: 새로운 사용자의 요청을 받는다.  
스레드1(5001) : B와 통신한다.  
이 상황에서 C가 A의 5000번 포트와 통신할 수 있다. 
그럼 또 새로운 소켓 5002 포트가 만들어지고 스레드2가 만들어지고 C는 5000번 포트와 연결이 끊기고 다시 5002번과 연결된다.

### `스레드`  
스레드가 있으면, 시간을 쪼개서 동시에 동작하는 것 처럼 보이게 할 수 있다.  
계속 연결되어 있기 때문에 A 입장에서 B가 누군지 계속 알 수 있다.  
연결이 지속되기 때문에 부하가 크다. 연결이 늘어나면 느려질 수 있다.  

### `HTTP 통신 예시`  
<img width="500" height="250" alt="HTTP" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/dae4824d-bd21-4600-8712-2d3d964cf761">

A가 C에게 a.txt 파일을 요청할때 C 소켓이 80으로 열려있을 때 새로운 스레드를 만드는 게 아니라  
다이렉트로 a.txt파일을 찾아서 A에게 돌려주고 더이상 통신할 수 없도록 선을 끊는다.  

연결이 끊기기 때문에 부하가 적지만, 다시 연결될 땐 항상 새로운 대상으로 인식한다. (구분하지 못한다.)  


# 9️⃣ 톰켓이란 무엇인가요?
HTTP는 운영체제가 가지고 있는 소켓을 이용해서 
프로그램이 운영체제가 들고있는 어떤 기능을 통해서 프로그램을 만들 때 이를 불러서 사용하는 것을 `시스템 콜`이라고 한다.

### 톰켓 vs 웹서버
`웹서버`: 컴퓨터를 하나 샀는데 재밌는 동영상 3개를 가지고 있다.  
친구들(을) 집에도 컴퓨터 있는데 내(갑) 동영상을 보고 싶다. 친구들이 내 데이터가 필요한 상황   

을이 필요한 데이터를 갑이 가지고 있다.  
을 -> request -> 갑
- 갑의 컴퓨터가 어디에 있는지 알아야해서 IP 주소를 알아야 한다.  
- 어떤 동영상을 요구하는지 정확하게 알아야 하기 때문에 URL(자원을 요청: 주소)

갑 -> respone -> 을
- request 할 때 을이 밝힌 IP 주소를 토대로 정보를 response해주면 된다.
- 갑은 웹서버가 된다.
- **갑은 을의 IP 주소를 모른다.** 알 필요가 없다. 을이 요청할 때만 응답해주면 되기 때문에
- 요청하지 않았을 때 응답 x -> 을의 주소를 몰라서!! => (연결이 지속된) 소켓을 써야함

<img width="740" alt="톰캣" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/2c7b6d9a-07e6-407a-9f5d-35f1a58c7ea1">

### `아파치` (웹서버)
아파치서버란 클라이언트에서 요청하는 `HTTP` 요청을 처리하는 웹서버를 의미한다.  
정적 타입(HTML, CSS, 이미지 등)의 데이터만을 처리한다. -> 톰캣이 등장한 이유  

웹서버는 흔히 아파치를 사용한다.  
컴퓨터에 폴더 하나를 지정하고 사람들한테 공유한다고 해보자  
a
request를 웹서버에 보내면 아파치는 response를 해주고 끝난다.  
만약 `.JSP(자바 코드)` 파일을 요청하면 아파치는 자바코드를 이해하지 못하고 응답할 수 없다.


### `톰켓` (WAS)
DB 처리와 같은 동적인 기능들을 가공하여 `HTML` 파일로 만들어 클라이언트에게 제공한다.  
- 자바 서블릿을 실행하고
- JSP 코드가 포함되어 있는 웹 페이지를 만들어준다.  
- 웹서버에서 넘어온 동적 페이지를 읽어들여 프로그램을 실행하고 그 결과를 다시 HTML로 재구성하여 아파치에게 되돌려 준다.

그렇기 때문에  
아파치에 톰켓을 단다.  
아파치가 이해하지 못하는 요청이 오면, 제어권을 톰캣에 넘겨버린다.  

### 1. 아파치 서버와 톰캣 서버 비교
|항목|아파치 서버|톰캣 서버|
|:-:|:-:|:-:|
|종류|웹 서버|WAS(Web Application server)|
|기능|정적 콘텐츠(HTML, CSS, 이미지 등) 제공|동적 콘텐츠 처리, 웹 애플리케이션 실행|
|프로토콜|주로 HTTP|HTTP, HTTPS, AJP 등|
|지원 언어|대부분의 웹 언어|주로 Java(Java Servlet, JavaServer Pages 등)|
|라이선스|Apache License 2.0|Apache License 2.0|
|사용 사례|회사 홈페이지, 블로그, 뉴스 사이트 등|온라인 쇼핑몰, 인터넷 뱅킹, SNS 등|
|장점|오픈소스로 무료 사용가능<br>다양한 운영체제에서 사용 가능<br>확장성이 뛰어나고 모듈화되어 있어 기능 추가가 쉽다|Java 기반의 웹 애플리케이션을 실행하고 관리하기 쉽다.<br>오픈소스로 무료 사용 가능<br>서블릿 컨테이너의 표준을 준수하여 다양한 웹 애플리케이션과 호환성이 좋다<br>경량화되어 있어서 시스템 자원 사용량이 적다.|
|단점|동적 콘텐츠 처리에는 적합하지 않다.|Java 외의 언어를 사용한 웹 애플리케이션에는 적합하지 않다.<br>대규모 웹 서비스에는 다른 WAS에 비해 성능이 떨어질 수 있다.|

### 2. 왜 아파치와 톰캣을 연동해서 사용하는 걸까?
웹페이지는 정적 데이터뿐만 아니라 동적 데이터도 함께 존재한다. 톰캣은 was서버이지만 web서버의 기능도 갖추고 있다. 하지만 아파치 웹서버보다 느린 처리속도를 제공하기 때문에 모든 데이터를 톰캣으로만 처리한다면 응답이 엄청 느려지게 될 것이다. 그래서 정적 데이터는 아파치가 동적 데이터는 톰캣이 분산 처리한다.


### `+서블릿`
클라이언트의 요청을 받고 요청을 처리하여 결과를 클라이언트에게 제공하는 자바 인터페이스

# 🔟 서블릿 객체의 생명주기가 궁금해요!
## 3.2 서블릿 컨테이너
### 1. 서블릿 컨테이너란?
<p align="center"><img width="400" alt="스프링컨테이너" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/a2d0b3d6-ac08-4021-b1ca-51d840048617"></p>

클라이언트가 요청하면 서블릿 컨테이너(톰캣)가 요청을 받고 최초 요청이면 객체를 생성하고  
최초 요청이 아니면 객체를 생성하지 않고 이미 생성된 객체를 재사용한다.  

정적 요청을 하면 아파치가 돈다 (톰켓이 일을 안한다.)  
스프링은 이런 파일을 요청할 수 없다.  

URL: 자원에 접근할 때 사용하는 주소 요청 방식  ->  스프링이 다 막아 놈
- http://naver.com/a.png  

URI(Identifier): 식별자를 통해 접근하는 방식  
- 특정한 파일 요청을 할 수 없다. 
- 요청시에는 무조건 자바를 거친다.
- 아파치는 제어권을 무조건 톰켓에 넘겨준다. (톰켓이 자바를 컴파일 할 수 있기 때문에)
- http://naver.com/picture/a

### 2. 서블릿 컨테이너의 역할과 기능
`WAS`(웹 애플리케이션 서버)의 일부로, HTTP요청을 받아 서블릿을 실행하고 응답을 클라이언트에게 전송하는 역할을 한다.  
- 웹 서버와 통신하여 HTTP 요청을 받고, 서블릿을 사용하여 요청을 처리한 후 응답을 클라이언트에게 전송한다.
- 네트워크 서비스, 스레드 관리, 서블릿 생명주기 관리 등을 담당한다. 
- 서블릿의 초기화, 호출, 소멸 등 생명 주기를 관리한다.
- 클라이언트로부터 요청이 들어오면, 서블릿 컨테이너는 해당 서블릿의 인스턴스를 생성하거나 재사용하고, 요청을 처리한 후 응답을 반환한다. 

- JSP, 필터, 리스너 등 다양한 웹 컴포넌트를 지원하여, 웹 애플리케이션 개발을 보다 유연하고 효율적으로 만든다. 이러한 컴포넌트를 통해 개발자는 요청 처리 과정을 쉽게 커스터마이징할 수 있기 때문이다.
- 세션 관리, 보안, 파일 업로드 처리 등 웹 애플리케이션 개발에 필요한 다양한 기능을 제공한다.  이를 통해 개발자는 보다 안전하고 효과적인 웹 애플리케이션을 구축할 수 있다.

### 3. 서블릿 컨테이너가 객체를 생성하는 방식
<p align="center"><img width="400" alt="서블릿컨테이너구조" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/9e99f8c2-a837-443d-b899-bc5ffc9cbc2b">

클라이언트로부터의 요청이 자바 관련 자원이면 무조건 서블릿 컨테이너(톰켓)가 요청된다.  
- 정적 자원이면 아파치만 실행된다.  (정적 웹서버)  

1. 클라이언트로부터 `최초의 요청`이 왔을 때 서버가 하는 일 : 서블릿 객체 `생성`(new) 
<p align="center"><img width="400" alt="최초요청" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/96eee5c7-952c-49a5-8f4f-34bb04cee9f4"></p>


- init() 호출
- service() 호출 -> POST, GET, PUT, DELETE 체크
    - get() 호출 -> DB 연결, 데이터 찾고 html에 담아서 응답하는 등 수행
    - 스레드1이 service()를 실행함

2. 클라이언트로부터 `두번째 요청`이 왔을 때 서버가 하는 일 : 서블릿 객체 `재사용`
<p align="center"><img width="400" alt="재사용" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/d005f378-4ed7-4578-abc7-8f6502325a5c"></p>

- init() 실행 x
- 새로운 스레드2를 만들어 service()를 호출한다.

> 자바의 메모리 영역 static, heap, stack을 떠올리면 이해할 수 있다.   
서블릿 객체는 무조건 하나만 만들어지고, 메소드는 따로 사용할 수 있다.

스레드를 20개 설정해놓고, 다 사용중일때 
21번째 요청이 들어오면 대기한다.  
이때 스레드1이 종료되면 제거하지 않고 21번째 요청이 스레드1을 재사용한다. (pooling 기법)   
스레드가 종료되는 시점은 response되는 시점이다.

### 4. Scale-Up & Scale-Out
`Scale-Up` : 기존 서버의 사양을 업그레이드해 시스템을 확장하는 것이다.  
`Scale-Out` : 서버를 여러 대 추가하여 시스템을 확장하는 것이다. (분산)

### 2. 스프링 컨테이너 vs 서블릿 컨테이너

<p align="center">
<img width="400" alt="스프링과서블릿컨테이너" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/c7d8779c-2167-42f6-ad0b-aba35914e0ab"></p>

## 참고
[[아파치, 톰캣] Apache? Tomcat?? 둘이 무슨 차이지?](https://velog.io/@kdhyo/Apache-Tomcat-%EB%91%98%EC%9D%B4-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EC%A7%80)  
[[아파치, 톰캣]톰캣 서버와 아파치 서버](https://velog.io/@moonblue/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%84%9C%EB%B2%84%EC%99%80-%ED%86%B0%EC%BA%A3-%EC%84%9C%EB%B2%84)  
[스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)이란?](https://dev-coco.tistory.com/143)