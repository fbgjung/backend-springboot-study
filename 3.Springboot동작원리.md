# 학습 내용
8강. HTTP가 무엇일까요? 정확히 알아야 해요  
9강. 톰캣이란 무엇인가요?  
10강. 서블릿 객체의 생명주기가 궁금해요!  
11강. 웹 배포서술자(web.xml)에 대해서 알려줘요!  
12강. 디스패처 서블릿이 무엇인가요?  
13강. 애플리케이션 컨텍스트란 무엇인가요?

# 8️⃣ HTTP가 무엇일까요? 정확히 알아야 해요
## 3.1 내장 톰켓을 가진다.
### `TCP & HTTP`
TCP 통신과 HTTP 통신이란 해당 계층에 해당되는 규약(protocol)아래에서 이루어지는 통신을 의미한다.  
TCP 통신: 
- 양방향 통신, 소켓을 이용한 연결 방식을 사용한다.  
-  양방향 통신으로 클라이언트단과 서버단의 연결이 끊어지지않고 계속 연결을 유지해주어 실시간 소통이 가능하다.   

HTTP 통신: 
- 단방향 통신
- HTTP는 TCP에 기반하여 만들어졌기 때문에, HTTP 통신 또한 소켓 기반이다. 
- HTTP 통신은 클라이언트의 요청이 왔을때만 서버단이 응답하고 처리를 해주며 해당 응답이 끝나면 연결을 바로 끊게 된다.  
- 연결을 지속시키지 않고 끊어버리는 `stateless` 방식을 사용한다.  
 

소켓을 이용한 연결은 TCP 프로토콜 기반으로 맺어진 연결이며, 소켓 통신이라고도 부른다.  

### `소켓`
네트워크를 서로 연결하는 연결부 같은 역할을 한다.   
방식에 따라 TCP 소켓과 UDP 방식으로 나뉜다.  
OSI 7 Layer의 네 번째 계층인 TCP 상에서 동작하는 소켓을 주로 사용하는데, 이를 TCP 소켓이라고 부른다.  
운영체제가 가지고 있는 것이다.

### `소켓연결`
TCP/IP 프로토콜 기반으로 맺어진 네트워크 연결이며, 소켓통신이라고도 부른다.
일반적으로, 서버는 특정 컴퓨터 위에서 돌아가고 특정 포트넘버에 할당된 소켓을 갖는다.  
이 서버는 클라이언트가 커넥션 요청을 만들기 위한 소켓을 리스닝하며 기다린다.  
클라이언트쪽에서 커넥션이 성립된 경우, 소켓이 성공적으로 생성되며 클라이언트는 소켓을 서버와 상호작용하기 위해 사용할 수 있다.  

네트워크 위에서 돌아가는 두 프로그램 간의 양방향 통신 링크의 엔드포인트다.  
소켓은 포트 넘버를 할당받아 TCP 레이어가 데이터의 목적지인 애플리케이션을 식별하도록 한다.  
엔드포인트는 IP 주소와 포트넘버의 조합이다.

즉 IP와 포트 넘버를 활용하여 만들어진 통신의 양끝단이다.  

### `소켓 프로그래밍`
Server와 Client가 특정 Port를 통해 연결을 유지하고 있어 실시간으로 양방향 통신을 하는 방식이다.  
실시간 스트리밍 중계나 실시간 채팅과 같이 즉각적으로 정보를 주고받는 경우에 사용한다.  


### `HTTP 통신`
HTTP 통신은 TCP 위에서 이루어진다.  
즉 HTTP 또한 소켓 통신을 활용한 방식이라고 볼 수 있다. !!!!  
HTTP 통신은 TCP 통신 기반에서 데이터를 전송하는 부분만 맡아서 역할을 한다.  
HTTP 통신을 하기위해서는 OSI 계층에서 TCP 기반인 4계층에서 3-way-handshake로 연결 과정을 거치고 7계층에서 HTTP 기반으로 데이터 전송을 하고 다시 4계층에서 4-way-handshake로 연결을 끊는 과정을 거쳐야 한다.  

특정 웹페이지를 들어가기 위해 브라우저에 naver.com을 입력하면 서버단에 요청이 들어오고 naver.com에 해당하는 내용들을 브라우저(클라이언트)에게 보내고 연결이 끊기면서 끝난다.

데이터 전송에 사용되는 소켓의 통신 방식이 TCP 통신의 데이터 전송에서 사용되는 소켓 통신과는 다른 방식으로 사용이된다.  

REST API도 HTTP 통신에 해당한다.  

### `HTTP 프로그래밍`
html 파일을 전송하거나, JSON, image 파일 등을 전송하는데 사용된다.  


### `소켓 통신 예시`
A,B가 메시지를 교환하기 위해서 운영체제가 제공하는 소켓을 이용하면 된다.  
A가 포트번호를 열고 소켓을 연다. 
이때, B가 A와 통신하고 싶으면 A의 IP주소와 포트번호를 넣으면 연결이된다.  
C가 A와 메시지를 교환하고 싶은데 B가 5000번 포트로 소켓와 연결되어 있기 때문에 C가 5000번으로 연결할 수 있는 방법이 없다.  
<img width="500" alt="소켓통신" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/dc8fdf95-7cc6-4bbd-a381-d7c6dd29758f">  

최초에 5000번 포트는 연결의 용도로만 사용한다. 5000번 포트가 연결되는 순간 새로운 소켓을 만든다.  
5001번(랜덤) 포트로 소켓이 만들어지고, 5000번 포트는 연결이 끊기고 5001 포트로 연결된다.  
5001번의 새로운 소켓을 만들 때는 새로운 스레드를 하나 만든다.

main 스레드: 새로운 사용자의 요청을 받는다.  
스레드1(5001) : B와 통신한다.  
이 상황에서 C가 A의 5000번 포트와 통신할 수 있다. 
그럼 또 새로운 소켓 5002 포트가 만들어지고 스레드2가 만들어지고 C는 5000번 포트와 연결이 끊기고 다시 5002번과 연결된다.

### `스레드`  
스레드가 있으면, 시간을 쪼개서 동시에 동작하는 것 처럼 보이게 할 수 있다.  
계속 연결되어 있기 때문에 A 입장에서 B가 누군지 계속 알 수 있다.  
연결이 지속되기 때문에 부하가 크다. 연결이 늘어나면 느려질 수 있다.  

### `HTTP 통신 예시`  
<img width="500" height="250" alt="HTTP" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/dae4824d-bd21-4600-8712-2d3d964cf761">

A가 C에게 a.txt 파일을 요청할때 C 소켓이 80으로 열려있을 때 새로운 스레드를 만드는 게 아니라  
다이렉트로 a.txt파일을 찾아서 A에게 돌려주고 더이상 통신할 수 없도록 선을 끊는다.  

연결이 끊기기 때문에 부하가 적지만, 다시 연결될 땐 항상 새로운 대상으로 인식한다. (구분하지 못한다.)  


# 9️⃣ 톰켓이란 무엇인가요?
HTTP는 운영체제가 가지고 있는 소켓을 이용해서 
프로그램이 운영체제가 들고있는 어떤 기능을 통해서 프로그램을 만들 때 이를 불러서 사용하는 것을 `시스템 콜`이라고 한다.

### 톰켓 vs 웹서버
`웹서버`: 컴퓨터를 하나 샀는데 재밌는 동영상 3개를 가지고 있다.  
친구들(을) 집에도 컴퓨터 있는데 내(갑) 동영상을 보고 싶다. 친구들이 내 데이터가 필요한 상황   

을이 필요한 데이터를 갑이 가지고 있다.  
을 -> request -> 갑
- 갑의 컴퓨터가 어디에 있는지 알아야해서 IP 주소를 알아야 한다.  
- 어떤 동영상을 요구하는지 정확하게 알아야 하기 때문에 URL(자원을 요청: 주소)

갑 -> respone -> 을
- request 할 때 을이 밝힌 IP 주소를 토대로 정보를 response해주면 된다.
- 갑은 웹서버가 된다.
- **갑은 을의 IP 주소를 모른다.** 알 필요가 없다. 을이 요청할 때만 응답해주면 되기 때문에
- 요청하지 않았을 때 응답 x -> 을의 주소를 몰라서!! => (연결이 지속된) 소켓을 써야함

<img width="740" alt="톰캣" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/2c7b6d9a-07e6-407a-9f5d-35f1a58c7ea1">

### `아파치` (웹서버)
아파치서버란 클라이언트에서 요청하는 `HTTP` 요청을 처리하는 웹서버를 의미한다.  
정적 타입(HTML, CSS, 이미지 등)의 데이터만을 처리한다. -> 톰캣이 등장한 이유  

웹서버는 흔히 아파치를 사용한다.  
컴퓨터에 폴더 하나를 지정하고 사람들한테 공유한다고 해보자  
a
request를 웹서버에 보내면 아파치는 response를 해주고 끝난다.  
만약 `.JSP(자바 코드)` 파일을 요청하면 아파치는 자바코드를 이해하지 못하고 응답할 수 없다.


### `톰켓` (WAS)
DB 처리와 같은 동적인 기능들을 가공하여 `HTML` 파일로 만들어 클라이언트에게 제공한다.  
- 자바 서블릿을 실행하고
- JSP 코드가 포함되어 있는 웹 페이지를 만들어준다.  
- 웹서버에서 넘어온 동적 페이지를 읽어들여 프로그램을 실행하고 그 결과를 다시 HTML로 재구성하여 아파치에게 되돌려 준다.

그렇기 때문에  
아파치에 톰켓을 단다.  
아파치가 이해하지 못하는 요청이 오면, 제어권을 톰캣에 넘겨버린다.  

### 1. 아파치 서버와 톰캣 서버 비교
|항목|아파치 서버|톰캣 서버|
|:-:|:-:|:-:|
|종류|웹 서버|WAS(Web Application server)|
|기능|정적 콘텐츠(HTML, CSS, 이미지 등) 제공|동적 콘텐츠 처리, 웹 애플리케이션 실행|
|프로토콜|주로 HTTP|HTTP, HTTPS, AJP 등|
|지원 언어|대부분의 웹 언어|주로 Java(Java Servlet, JavaServer Pages 등)|
|라이선스|Apache License 2.0|Apache License 2.0|
|사용 사례|회사 홈페이지, 블로그, 뉴스 사이트 등|온라인 쇼핑몰, 인터넷 뱅킹, SNS 등|
|장점|오픈소스로 무료 사용가능<br>다양한 운영체제에서 사용 가능<br>확장성이 뛰어나고 모듈화되어 있어 기능 추가가 쉽다|Java 기반의 웹 애플리케이션을 실행하고 관리하기 쉽다.<br>오픈소스로 무료 사용 가능<br>서블릿 컨테이너의 표준을 준수하여 다양한 웹 애플리케이션과 호환성이 좋다<br>경량화되어 있어서 시스템 자원 사용량이 적다.|
|단점|동적 콘텐츠 처리에는 적합하지 않다.|Java 외의 언어를 사용한 웹 애플리케이션에는 적합하지 않다.<br>대규모 웹 서비스에는 다른 WAS에 비해 성능이 떨어질 수 있다.|

### 2. 왜 아파치와 톰캣을 연동해서 사용하는 걸까?
웹페이지는 정적 데이터뿐만 아니라 동적 데이터도 함께 존재한다. 톰캣은 was서버이지만 web서버의 기능도 갖추고 있다. 하지만 아파치 웹서버보다 느린 처리속도를 제공하기 때문에 모든 데이터를 톰캣으로만 처리한다면 응답이 엄청 느려지게 될 것이다. 그래서 정적 데이터는 아파치가 동적 데이터는 톰캣이 분산 처리한다.


### `+서블릿`
클라이언트의 요청을 받고 요청을 처리하여 결과를 클라이언트에게 제공하는 자바 인터페이스

# 🔟 서블릿 객체의 생명주기가 궁금해요!
## 3.2 서블릿 컨테이너
### 1. 서블릿 컨테이너란?
<p align="center"><img width="400" alt="스프링컨테이너" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/a2d0b3d6-ac08-4021-b1ca-51d840048617"></p>

클라이언트가 요청하면 서블릿 컨테이너(톰캣)가 요청을 받고 최초 요청이면 객체를 생성하고  
최초 요청이 아니면 객체를 생성하지 않고 이미 생성된 객체를 재사용한다.  

정적 요청을 하면 아파치가 돈다 (톰켓이 일을 안한다.)  
스프링은 이런 파일을 요청할 수 없다.  

URL: 자원에 접근할 때 사용하는 주소 요청 방식  ->  스프링이 다 막아 놈
- http://naver.com/a.png  

URI(Identifier): 식별자를 통해 접근하는 방식  
- 특정한 파일 요청을 할 수 없다. 
- 요청시에는 무조건 자바를 거친다.
- 아파치는 제어권을 무조건 톰켓에 넘겨준다. (톰켓이 자바를 컴파일 할 수 있기 때문에)
- http://naver.com/picture/a

### 2. 서블릿 컨테이너의 역할과 기능
`WAS`(웹 애플리케이션 서버)의 일부로, HTTP요청을 받아 서블릿을 실행하고 응답을 클라이언트에게 전송하는 역할을 한다.  
- 웹 서버와 통신하여 HTTP 요청을 받고, 서블릿을 사용하여 요청을 처리한 후 응답을 클라이언트에게 전송한다.
- 네트워크 서비스, 스레드 관리, 서블릿 생명주기 관리 등을 담당한다. 
- 서블릿의 초기화, 호출, 소멸 등 생명 주기를 관리한다.
- 클라이언트로부터 요청이 들어오면, 서블릿 컨테이너는 해당 서블릿의 인스턴스를 생성하거나 재사용하고, 요청을 처리한 후 응답을 반환한다. 

- JSP, 필터, 리스너 등 다양한 웹 컴포넌트를 지원하여, 웹 애플리케이션 개발을 보다 유연하고 효율적으로 만든다. 이러한 컴포넌트를 통해 개발자는 요청 처리 과정을 쉽게 커스터마이징할 수 있기 때문이다.
- 세션 관리, 보안, 파일 업로드 처리 등 웹 애플리케이션 개발에 필요한 다양한 기능을 제공한다.  이를 통해 개발자는 보다 안전하고 효과적인 웹 애플리케이션을 구축할 수 있다.

### 3. 서블릿 컨테이너가 객체를 생성하는 방식
<p align="center"><img width="400" alt="서블릿컨테이너구조" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/9e99f8c2-a837-443d-b899-bc5ffc9cbc2b">

클라이언트로부터의 요청이 자바 관련 자원이면 무조건 서블릿 컨테이너(톰켓)가 요청된다.  
- 정적 자원이면 아파치만 실행된다.  (정적 웹서버)  

1. 클라이언트로부터 `최초의 요청`이 왔을 때 서버가 하는 일 : 서블릿 객체 `생성`(new) 
<p align="center"><img width="400" alt="최초요청" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/96eee5c7-952c-49a5-8f4f-34bb04cee9f4"></p>


- init() 호출
- service() 호출 -> POST, GET, PUT, DELETE 체크
    - get() 호출 -> DB 연결, 데이터 찾고 html에 담아서 응답하는 등 수행
    - 스레드1이 service()를 실행함

2. 클라이언트로부터 `두번째 요청`이 왔을 때 서버가 하는 일 : 서블릿 객체 `재사용`
<p align="center"><img width="400" alt="재사용" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/d005f378-4ed7-4578-abc7-8f6502325a5c"></p>

- init() 실행 x
- 새로운 스레드2를 만들어 service()를 호출한다.

> 자바의 메모리 영역 static, heap, stack을 떠올리면 이해할 수 있다.   
서블릿 객체는 무조건 하나만 만들어지고, 메소드는 따로 사용할 수 있다.

스레드를 20개 설정해놓고, 다 사용중일때 
21번째 요청이 들어오면 대기한다.  
이때 스레드1이 종료되면 제거하지 않고 21번째 요청이 스레드1을 재사용한다. (pooling 기법)   
스레드가 종료되는 시점은 response되는 시점이다.

### 4. Scale-Up & Scale-Out
`Scale-Up` : 기존 서버의 사양을 업그레이드해 시스템을 확장하는 것이다.  
`Scale-Out` : 서버를 여러 대 추가하여 시스템을 확장하는 것이다. (분산)

### 2. 스프링 컨테이너 vs 서블릿 컨테이너
<p align="center">
<img width="400" alt="스프링과서블릿컨테이너" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/c7d8779c-2167-42f6-ad0b-aba35914e0ab"></p>


# 1️⃣1️⃣ 웹 배포서술자(web.xml)에 대해서 알려줘요!
서블릿은 자바와 달리 main() 메소드로 직접 호출되지 않고, 웹 컨테이너(Servlet Container)에 의해 실행된다. 컨테이너가 web.xml을 읽고, 서블릿 클래스를 클래스 로더에 등록하는 절차를 밟는다.
## 3.3 web.xml
- `DD`(Deployment Descriptor: 배포 설명자)라고 불리며, web application의 설정파일이다.
- 모든 web application은 반드시 하나의 web.xml 파일을 가져야한다. 
- web application 실행 시 메모리에 로딩된다.

    - 만약 톰캣이라는 WAS를 통해 이 web application을 실행시킨다고 가정하면, web.xml 파일에 설정한 내용들이 메모리에 로드될 것이다.
- WEB-INF 폴더 아래에있다.
- 크게 `DispatcherServlet`, `ContextLoaderListener`, `Filter` 설정을 한다. 
    
    - `DispatcherServlet` : 클라이언트의 요청을 처리한다.
    - `ContextLoaderListener` : 웹 애플리케이션 컨텍스트 단위의 설정을 로드한다.

### `서블릿을 등록`하는 것인가?
서블릿 컨테이너는 일반적으로 웹 애플리케이션 서버(아파치, 톰캣 등) 내에서 실행되며, 서블릿은 배포 서술자(web.xml) 파일이나 어노테이션을 사용하여 등록된다. 어노테이션을 사용하는 것이 더 일반적이다.
1. 어노테이션을 사용한 서블릿 등록
```java
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("HelloServlet.service");
        System.out.println("request = " + request);
        System.out.println("response = " + response);

        String username = request.getParameter("username"); // http://localhost:8080/hello?username=kim query parameter 조회
        System.out.println("username = " + username);

        // ContentType header 정보에 들어간다.
        response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");

        response.getWriter().write("hello " + username);
    }
}
```
2. `web.xml`을 사용한 서블릿 등록

### 1. ServletContext의 초기 파라미터
애플리케이션 전역에서 사용할 수 있는 초기화 매개변수를 정의한다.

### 2. Session의 유효시간 설정
인증을 통해 들어오는게 세션

### 3. Servlet/JSP에 대한 정의
### 4. Servlet/JSP 매핑
요청한 자원이 어디인지 정확하게 알려주고, 이동할수 있도록 도와준다.

### 5. Mime Type 매핑
- Multipurpose Internet Mail Extensions
- MIME으로 인코딩한 파일은 Content-type 필드를 헤더에 담게되며 이를 통해 `전송된 자원의 형식을 명시`할 수 있다.
- 인터넷에 전달되는 파일 포맷 및 포맷 컨텐츠를 위한 식별자
- ex) application/json : 바이너리 파일 중 json 포맷의 파일을 의미하는 식별자로서 기능한다.   

데이터 타입  
아무 데이터도 가져오지 않으면 GET방식의 요청을 하기 위함이다.  
Mime Type이 틀리면, Error가 발생한다.  
종류가 굉장히 많으므로 따로 학습이 필요하다.  

### 6. Welcome File list
```xml
<welcome-file-list>
    <welcome-file>/WEB-INF/views/index1.jsp</welcome-file>
    <welcome-file>/WEB-INF/views/index2.jsp</welcome-file>
</welcome-file-list>
```
데이터도, 어디로 갈지도 아무것도 들고오지 않은 상태에서 문지기는 어디로 보내야 할까  
관리자가 광장으로 보낸다. 일거리를 찾을 수 있도록  
관리자가 누구인지에 따라 Welcome File은 설정하기 나름이다.  

### 6-1. Welcome File List를 사용하는 이유
일반적으로 웹에서 메인페이지를 보여줄때 메인페이지를 보여주는 url을 main.do 형태로 설정할 경우 사용자가 http://localhost:8080/main.do 형태의 URL로 접근하기보다는 http://localhost:8080/ 형태의 주소로 들어오는 경우가 대부분일 텐데 이 경우에는 페이지가 없기 때문에 404 에러가 발생할 것이다.  
하지만 <welcome-file-list>를 설정해놓고 main.do 페이지로 리다이렉트 시켜준다면 사용자가 http://localhost:8080/ 로 접근했을지라도 자연스럽게 메인페이지로 이동하게 된다. 
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%response.sendRedirect(request.getContextPath()+"/main.do"); %>
```

### 7. Error Pages 처리
```xml
<error-page>
    <error-code>404</error-code>
    <location>/error404</location>
</error-page>
```
<error-page>에 해당되는 에러코드를 입력하고 <location>에 맵핑되는 Controller 주소를 입력한다. 

### 8. 리스너/필터 설정
`필터`: a의 신분을 확인하는 것, a가 총을 소지하고있으면 문지기가 총을 뺏고 들여보내는 등

`리스너`: 성의 관리자가 술을 잘먹는 사람이 필요하다. 리스너로 등록을 해놓는다. 문지기 한테 찾아내라고 한다. 근데 문지기는 web.xml에 할일이 너무 많다. 이때 관리자는 리스너를 만든다. 리스너는 술 잘먹는 사람만 확인하는 대리인 느낌
- 리스너로 등록되면 톰캣 컨테이너가 시작 및 종료 시에 이벤트를 감지할 수 있다.

1. web.xml에 태그를 사용하여 등록
2. @WebListener 어노테이션을 사용하여 등록
```java
@WebListener
public class ServletContextListenerImpl 
	implements ServletContextListener {  
}
```
### 9. 보안
내 성을 보호하는 것이다.  쫓아내 ~~

# 1️⃣2️⃣ 디스패처 서블릿이 무엇인가요?
## 3.4 FrontController 패턴
`스프링에서 FrontController 패턴은 모든 HTTP 요청을 받아서 적합한 컨트롤러에 위임하는 역할을 한다.`

### `FrontController 패턴 특징`
>`최초 앞단에서 request 요청을 받아서` 필요한 클래스에 넘겨준다. 왜? web.xml에 다 정의하기가 너무 힘듦  
이때 새로운 요청이 생기기 때문에 request와 response가 새롭게 new될 수 있다.  
그래서 RequestDispatcher가 필요하다. 

- FrontController 서블릿 하나로 클라이언트의 요청을 받음
- FrontController가 요청에 맞는 컨트롤러를 찾아서 호출 (매핑이 일어남)
- 입구를 하나로, 공통 처리 가능 -> 유지보수
- FrontController를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨 -> FrontController에 위임한 것
- 클라이언트는 FrontController의 URL만 알면된다.


## 3.5 RequestDispatcher
> 필요한 클래스 요청이 도달했을 때 FrontController에 도착한 request와 response를 그대로 유지시켜준다.  

- a.jsp로 들어온 요청을 /a.jsp 내에서 b.jsp로 요청을 보낼 수 있다.
- a.jsp에서 b.jsp로 처리를 요청하고 b.jsp에서 처리한 결과 내용을 a.jsp의 결과에 포함시킬 수 있다.

- JSP와 servlet 사이에서 request와 response를 전달하는 기능 제공
    - 데이터를 공유하면서 같이 사용할 수 있음
- 요청 주소는 여전히 기존 주소로 유지됨 (sendRedirect 메서드는 주소도 바뀐다.)
    - 클라이언트는 전달받은 servlet or JSP의 정확한 주소를 알지 못해서 보안 좋다.

### `JSP`
>JSP 페이지는 HTML 코드 안에 Java 코드를 포함할 수 있는 특별한 형식의 파일이다.  
JSP 페이지는 웹 애플리케이션 서버에서 Java Servlet으로 변환되어 실행된다.  
주로 웹 애플리케이션의 사용자 인터페이스(UI)를 구성하고 동적 데이터를 표시하는 데 사용된다.


## 3.6 DispatchServlet (FrontController + RequestDispatcher)
> FrontController 패턴을 직접짜거나 RequestDispatcher를 직접 구현할 필요가 없다.  
왜냐하면 스프링에는 DispatchServlet이 있기 때문이다.  
DispatchServlet이 자동생성되어 질 때 수 많은 객체가 생성(IoC)된다. 보통 필터들이다.  (필터, 컨트롤러, 리파지토리 등등)
해당 필터들은 내가 직접 등록할 수도 있고 기본적으로 필요한 필터들은 자동 등록 되어진다.  



## 프론트 컨트롤러 도입 전 예시
```java
// 회원 등록과 저장
@WebServlet(name = "mvcMemberFormServlet", urlPatterns = "/servlet-mvc/members/new-form")
public class MvcMemberFormServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String viewPath = "/WEB-INF/views/new-form.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response); // forward 메서드는 서버 내부에서 요청을 다른 리소스로 전달함
    }
}

@WebServlet(name = "mvcMemberSaveServlet", urlPatterns = "/servlet-mvc/members/save")
public class MvcMemberSaveServlet extends HttpServlet {
    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        Member member = new Member(username, age);
        System.out.println("member = " + member);
        memberRepository.save(member);
        //Model에 데이터를 보관한다.
        request.setAttribute("member", member);
        String viewPath = "/WEB-INF/views/save-result.jsp";

        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    } 
}
```
- 서블릿을 컨트롤러 마다 생성해줘야 한다.

## 프론트 컨트롤러 도입 코드 예시(가장 기본 구조) 
> FrontController에서 매핑 정보를 조회할 때 다형성을 적용하도록 `컨트롤러 인터페이스`를 선언하고,  
각 컨트롤러마다 인터페이스를 구현하도록 한다.  
>
>FrontController를 도입함으로써 모든 요청은 FrontController 클래스가 먼저 받고,  
공통 로직을 처리한 후 호출될 컨트롤러의 매핑 정보를 URL로부터 찾아서 컨트롤러를 호출하는 방식으로 변경되었다. 

### `컨트롤러 인터페이스`
```java
public interface ControllerV1 {
    void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
 }
```
서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다.  
각 컨트롤러는 이 인터페이스를 구현하면 된다.  
FrontController는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가져갈 수 있다.  

### `회원 등록 컨트롤러`
```java
public class MemberFormControllerV1 implements ControllerV1 {
    @Override
    public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String viewPath = "/WEB-INF/views/new-form.jsp";

        // request, response 객체를 보낼 대상 파일 지정
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response); 
    } 
}
```
- forward() 
    - 서버 내부에서만 작동함
    - request와 response를 그대로 넘김

### `회원 저장 컨트롤러`
```java
public class MemberSaveControllerV1 implements ControllerV1 {
    private MemberRepository memberRepository = MemberRepository.getInstance();
    @Override
    public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        Member member = new Member(username, age);
        memberRepository.save(member);
        request.setAttribute("member", member);
        String viewPath = "/WEB-INF/views/save-result.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatch(viewPath);
        dispatcher.forward(request, response);
    }
}
```

### `FrontController`  
```java
// 서블릿이 /front-controller/v1/* URL 패턴에 매핑됨
@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")

// HttpServlet을 상속해서 서블릿의 기본 기능을 제공받음
public class FrontControllerServletV1 extends HttpServlet {

    // URL 경로를 ControllerV1 인터페이스를 구현한 컨트롤러 객체에 매핑하는 맵
    private Map<String, ControllerV1> controllerMap = new HashMap<>();
    public FrontControllerServletV1() {

        // 경로, 해당 컨트롤러를 맵에 등록
        controllerMap.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
        controllerMap.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
    }

    // 요청 처리 메서드
    // service 메서드는 들어오는 HTTP 요청을 처리함
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("FrontControllerServletV1.service");
        String requestURI = request.getRequestURI(); // 요청된 URI를 가져옴
        ControllerV1 controller = controllerMap.get(requestURI); // URI를 통해 controllerMap에서 적절한 컨트롤러 객체를 찾음
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return; }
        controller.process(request, response); // 해당 컨트롤러의 process 메서드를 호출하여 요청 처리
    }
}
```

# 1️⃣3️⃣ 애플리케이션 컨텍스트란 무엇인가요?
## 3.7 스프링 컨테이너
- 자바 객체의 생명 주기 관리
- 생성된 자바 객체들에게 추가적인 기능 제공
- 스프링에서는 **자바 객체를 빈(Bean)** 이라 한다
- XML, 어노테이션 기반의 자바 설정 클래스로 만든다. (XML은 스프링 부트가 등장하면서 대부분 사용x)
- `BeanFactory`, `ApplicationContext` 두 종류의 인터페이스로 구현되어 있다. 

### 스프링 컨테이너를 사용하는 이유
1. 객체 간의 의존성을 낮추어(느슨한 결합) **결합도는 낮추고, 높은 캡슐화를 위해**  
객체를 생성하기 위해서는 new 생성자를 사용해야 한다. 그로인해 애플리케이션에서는 수많은 객체가 존재하고 서로를 참조하게 된다.  
객체 간의 참조가 많을수록 의존성이 높아지는데 이는 낮은 결합도와 높은 캡슐화를 지향하는 객체지향 프로그래밍의 핵심과는 먼 방식이다.
2. 구현 클래스에 있는 의존성을 제거하고 **인터페이스에만 의존하도록 설계할 수 있다.**    
기존의 방식으로는 새로운 기능이 생기게 되면 변경 사항들을 수작업으로 수정해야 한다.  
프로젝트가 커질수록 의존도는 높아질 것이고, 그에 따라 코드의 변경도 많아질 것이다.  


## DispatchServlet에 의해 생성되어지는 수 많은 객체들은 어디에서 관리될까?

### **첫째, ApplicationContext**  
- 스프링 프레임워크에서 제공하는 핵심 컨테이너이며, `IoC 컨테이너의 한 종류`이다.
- 빈의 생성과 관리를 담당한다. 

> 수 많은 객체들이 ApplicationContext에 등록된다(DispatchServlet이 컴포넌트 스캔할 때) 이것을 IoC라고 한다.  IoC란 제어의 역전을 의미한다. 개발자가 직접 new를 통해 객체를 생성하게 된다면 해당 객체를 가르키는 레퍼런스 변수를 관리하기 어렵다. 그래서 스프링이 직접 해당 객체를 관리한다(우리는 어떤 어노테이션을 스프링이 관리하는지를 알아야한다.). 이때 우리는 주소를 몰라도 된다. 왜냐하면 필요할 때 DI(의존성 주입)하면 되기 때문이다.  
필요한 곳에서 ApplicationContext에 접근하여 필요한 객체를 가져올 수 있다.  
ApplicationContext는 싱글톤으로 관리되기 때문에 어디에서 접근하든 동일한 객체라는 것을 보장해준다.  

### `ApplicationContext의 종류`
1. `servlet-applicationContext`: ViewResolver, Interceptor, MultipartResolver 객체를 생성하고 **웹과 관련된 어노테이션** Controller, RestController를 스캔한다.  
    - 해당 파일은 `DispatchServlet`에 의해 실행된다. 
    - Controllers, ViewResolver, HandlerMapping

2. `root-applicationContext`: 해당 어노테이션을 제외한 어노테이션 Service, Repository 등을 스캔하고 DB관련 객체를 생성한다. (스캔: 메모리에 로딩한다는 뜻)  
    - 해당 파일은 `ContextLoaderListener`에 의해 실행된다.  
    - ContextLoaderListener를 실행해주는 것은 web.xml이기 때문에 root-applicationContext는 servlet-applicationContext보다 먼저 로드된다. 
    - servlet-applicationContext에서는 root-applicationContext가 로드한 객체를 참조할 수 있지만 그 반대는 불가능하다. (생성 시점이 다르기 때문에)
    - 데이터베이스와 관련된 일을 할 수 있는 Service, Repository에 접근



### 요청이 들어오면 web.xml에서 스프링으로 들어오기 위해서 두가지 일을한다. 
1. `DispatchServlet`
    - frontcontroller + requestDispatcher
    - src 폴더 안에 자바파일들이 **메모리에 떠있어야한다**. `DispatchServlet`이 `컴포넌트 스캔`을 통해서 객체를 생성하고, 필요한 것을(@Controller, @RestController, @Repository 등등)메모리에 올린다. (스프링부트는 파일 전체를 스캔한다. 특정한 자바 클래스를 IoC 컨테이너에 객체를 띄우고 싶고, 스프링을 이를 미리 정해두었다.)
    - 자바 클래스가 메모리에 떠 있다면, DispatchServlet은 **주소를 분배한다.**

2. `ContextLoaderListener`
    - DispatchServlet 이전에 실행된다. 
    - Servlet이 만들어지면 가장 먼저 스레드가 만들어진다. (각각의 스레드는 독립적이라, 서로 영향을 받지않는다.)
    - **모든 요청이 공통적으로 사용해야하는 것들을 미리 ContextLoaderListener를 통해서 띄운다.** (DB Connection)
    - root-ApplicationContext라는 파일을 읽는다.**root-ApplicationContext은 스레드가 공통적으로 사용해야하는 것**들을 메모리에 띄워준다. (이를 IoC 컨테이너에서 관리한다.)
    - DB에서는 DispatchServlet에서 띄운 메모리에 접근을 하지 못한다. 
    - 반대로 DispatchServlet에서 메모리에 띄운 클래스들은 DB에 접근할 수 있다. 


### **둘째, Bean Factory**
> 필요한 객체를 Bean Factory에 등록할 수도 있다. 여기에 등록하면 초기에 메모리에 로드되지 않고 **필요할 때 `getBean()`이라는 메소드를 통해 호출하여 메모리에 로드**할 수 있다. 이것또한 IoC이다.  
그리고 필요할 때 DI하여 사용할 수 있다.  
ApplicationContext와 다른 점은 Bean Factory에 로드되는 객체들은 미리 로드되지 않고 **필요할 때 호출하여 로드**하기 때문에 lazy-loading된다는 점이다. 

컴포넌트스캔 할 때 @Configuration이 등록되어있는 클래스가 메모리에 뜬다. 
메소드들이 반환하는 객체가 있다면, `@Bean`을 통해 메모리에 띄울 수 있다.  

### BeanFactory vs ApplicationContext
|BreanFactory|ApplicationContext|
|-|-|
|빈을 생성하고 의존관계를 설정하는 기능을 담당하는 가장 기본적인 IoC 컨테이너이자 클래스<br>스프링 빈 컨테이너에 접근하기 위한 최상위 인터페이스이다.|BeanFactory를 확장하여 더 많은 기능을 제공하는 IoC 컨테이너이다.|
|Lazy-loading: 빈을 사용할 때 빈을 로딩한다. 필요할 때만 로딩하기 때문에, 가벼운 경량 컨테이너이다.|Eager-loading: 런타임 실행시 모든 빈을 미리 로딩하여 초기화한다.|
|빈을 사용할 때마다 초기화되어 비용이 발생하지 않는다. 메모리 사용을 최적화할 수 있다.|애플리케이션 시작 시 모든 빈을 초기화하므로 초기 구동 시간이 길어질 수 있으나, 런타임 동안 성능이 향상된다.|

스프링 공식문서에 의하면 특별한 경우가 아니라면 BeanFactory의 모든 기능을 포함하고 추가 기능을 제공하는 ApplicationContext를 사용하기를 권장하고 있다. 


### ApplicationContext 초기화
1. `web.xml`을 이용하여 ContextLoaderListener 사용
```xml
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<context-param>
    <param-name>contextClass</param-name>
    <param-value>org.springframework.web.context.ContextLoader</param-value>
</context-param>

<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/applicationContext.xml</param-value>
</context-param>
```
- ContextLoaderListener는 웹 애플리케이션이 시작될 때 spring applicationContext를 초기화하고 필요한 빈들을 로드하는 역할을 한다. 
- ContextLoaderLister가 등록되면 웹 애플리케이션이 호출되고, 내부적으로 WebApplicationContext를 생성하고 ServletContext에 등록한다. 

2. `SpringBoot 프레임워크`를 이용한 초기화

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```
- @SpringBootApplication 어노테이션을 사용하면 자동으로 ApplicationContext 초기화가 이루어진다.
- 내장 톰캣을 사용하고 있기 때문이다.
- @SpringBootApplication 어노테이션은 @Configuration, @EnableAutoConfiguration, @ComponentScan을 포함하고 있다. 
- SpringApplication.run() 메소드는 ApplicationContext를 초기화하고 애플리케이션을 실행하는 역할을 한다. 

> Springboot는 내부적으로 톰캣을 내장하고 있어서 초기화가 자동으로 이루어지는 반면, ContextLoaderListener를 사용하는 경우에는 일부 외부 서버(톰캣)에서 애플리케이션을 실행하는 경우가 일반적이기 때문에 web.xml에 명시적으로 작성하여 초기화가 이루어진다. 




## 참고
[[아파치, 톰캣] Apache? Tomcat?? 둘이 무슨 차이지?](https://velog.io/@kdhyo/Apache-Tomcat-%EB%91%98%EC%9D%B4-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EC%A7%80)  
[[아파치, 톰캣]톰캣 서버와 아파치 서버](https://velog.io/@moonblue/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%84%9C%EB%B2%84%EC%99%80-%ED%86%B0%EC%BA%A3-%EC%84%9C%EB%B2%84)  
[스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)이란?](https://dev-coco.tistory.com/143)  
[[MIME type] MIME type은 뭐고, Content-type은 뭔데?](https://velog.io/@rookieand/MIME-type%EC%9D%80-%EB%AD%90%EA%B3%A0-Content-type%EC%9D%80-%EB%AD%94%EB%8D%B0)  
[[Error page] web.xml - Error Page 설정](https://2kid.tistory.com/2)  


[[Spring] 스프링 컨테이너(Spring Container)란 무엇인가?](https://ittrue.tistory.com/220)  
[[Spring] Application Context](https://velog.io/@wooyong99/Spring-Application-Context)   
[BeanFactory 와 ApplicationContext의 차이](https://velog.io/@saint6839/BeanFactory-%EC%99%80-ApplicationContext%EC%9D%98-%EC%B0%A8%EC%9D%B4)  


[ServletContainer와 SpringContainer는 무엇이 다른가?](https://sigridjin.medium.com/servletcontainer%EC%99%80-springcontainer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-626d27a80fe5)
